{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Class that handles response parsing.\r\n */\n\nvar ResponseHandler =\n/** @class */\nfunction () {\n  function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param cachedState\r\n   * @param cryptoObj\r\n   */\n\n\n  ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n\n    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n      throw ClientAuthError.createStateMismatchError();\n    } // Check for error\n\n\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\n      }\n\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  };\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   */\n\n\n  ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n\n      var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\n      throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\n    }\n  };\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n\n            if (serverTokenResponse.id_token) {\n              idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj); // token nonce check (TODO: Add a warning if no nonce is given?)\n\n              if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                  throw ClientAuthError.createNonceMismatchError();\n                }\n              } // token max_age check\n\n\n              if (request.maxAge || request.maxAge === 0) {\n                authTime = idTokenObj.claims.auth_time;\n\n                if (!authTime) {\n                  throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n\n                AuthToken.checkMaxAge(authTime, request.maxAge);\n              }\n            } // generate homeAccountId\n\n\n            this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims);\n\n            if (!!authCodePayload && !!authCodePayload.state) {\n              requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n            } // Add keyId from request to serverTokenResponse if defined\n\n\n            serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 5, 8]);\n\n            if (!(this.persistencePlugin && this.serializableCache)) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n            cacheContext = new TokenCacheContext(this.serializableCache, true);\n            return [4\n            /*yield*/\n            , this.persistencePlugin.beforeCacheAccess(cacheContext)];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n              key = cacheRecord.account.generateAccountKey();\n              account = this.cacheStorage.getAccount(key);\n\n              if (!account) {\n                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                return [2\n                /*return*/\n                , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.cacheStorage.saveCacheRecord(cacheRecord)];\n\n          case 4:\n            _b.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 5:\n            if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3\n            /*break*/\n            , 7];\n            this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n            return [4\n            /*yield*/\n            , this.persistencePlugin.afterCacheAccess(cacheContext)];\n\n          case 6:\n            _b.sent();\n\n            _b.label = 7;\n\n          case 7:\n            return [7\n            /*endfinally*/\n            ];\n\n          case 8:\n            return [2\n            /*return*/\n            , ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n\n\n  ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\n    var env = authority.getPreferredCache();\n\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    } // IdToken: non AAD scenarios can have empty realm\n\n\n    var cachedIdToken;\n    var cachedAccount;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\n      cachedAccount = AccountEntity.createAccount({\n        homeAccountId: this.homeAccountIdentifier,\n        idTokenClaims: idTokenObj.claims,\n        clientInfo: serverTokenResponse.client_info || Constants.EMPTY_STRING,\n        cloudGraphHostName: authCodePayload === null || authCodePayload === void 0 ? void 0 : authCodePayload.cloud_graph_host_name,\n        msGraphHost: authCodePayload === null || authCodePayload === void 0 ? void 0 : authCodePayload.msgraph_host\n      }, authority);\n    } // AccessToken\n\n\n    var cachedAccessToken = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\n      // If scopes not returned in server response, use request scopes\n      var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n\n      var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      var tokenExpirationSeconds = reqTimestamp + expiresIn;\n      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined; // non AAD scenarios can have empty realm\n\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    } // refreshToken\n\n\n    var cachedRefreshToken = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    } // appMetadata\n\n\n    var cachedAppMetadata = null;\n\n    if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  };\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n\n\n  ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, serverTokenResponse, requestId) {\n    var _a, _b, _c;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            accessToken = Constants.EMPTY_STRING;\n            responseScopes = [];\n            expiresOn = null;\n            familyId = Constants.EMPTY_STRING;\n            if (!cacheRecord.accessToken) return [3\n            /*break*/\n            , 4];\n            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(cryptoObj);\n            _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\n\n            if (!keyId) {\n              throw ClientAuthError.createKeyIdMissingError();\n            }\n\n            return [4\n            /*yield*/\n            , popTokenGenerator.signPopToken(secret, keyId, request)];\n\n          case 1:\n            accessToken = _e.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            accessToken = cacheRecord.accessToken.secret;\n            _e.label = 3;\n\n          case 3:\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            _e.label = 4;\n\n          case 4:\n            if (cacheRecord.appMetadata) {\n              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\n            }\n\n            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\n            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING; // for hybrid + native bridge enablement, send back the native account Id\n\n            if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {\n              cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;\n            }\n\n            return [2\n            /*return*/\n            , {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes,\n              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n              idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\n              idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n              accessToken: accessToken,\n              fromCache: fromTokenCache,\n              expiresOn: expiresOn,\n              correlationId: request.correlationId,\n              requestId: requestId || Constants.EMPTY_STRING,\n              extExpiresOn: extExpiresOn,\n              familyId: familyId,\n              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\n              state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\n              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\n              code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,\n              fromNativeBroker: false\n            }];\n        }\n      });\n    });\n  };\n\n  return ResponseHandler;\n}();\n\nexport { ResponseHandler };","map":{"version":3,"sources":["../../src/response/ResponseHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ServerAuthorizationTokenResponse } from \"./ServerAuthorizationTokenResponse\";\r\nimport { buildClientInfo} from \"../account/ClientInfo\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ServerAuthorizationCodeResponse } from \"./ServerAuthorizationCodeResponse\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { ServerError } from \"../error/ServerError\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AuthenticationResult } from \"./AuthenticationResult\";\r\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity\";\r\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity\";\r\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity\";\r\nimport { InteractionRequiredAuthError } from \"../error/InteractionRequiredAuthError\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { CacheManager } from \"../cache/CacheManager\";\r\nimport { ProtocolUtils, RequestStateObject } from \"../utils/ProtocolUtils\";\r\nimport { AuthenticationScheme, Constants, THE_FAMILY_ID } from \"../utils/Constants\";\r\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\r\nimport { AppMetadataEntity } from \"../cache/entities/AppMetadataEntity\";\r\nimport { ICachePlugin } from \"../cache/interface/ICachePlugin\";\r\nimport { TokenCacheContext } from \"../cache/persistence/TokenCacheContext\";\r\nimport { ISerializableTokenCache } from \"../cache/interface/ISerializableTokenCache\";\r\nimport { AuthorizationCodePayload } from \"./AuthorizationCodePayload\";\r\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\r\n\r\n/**\r\n * Class that handles response parsing.\r\n */\r\nexport class ResponseHandler {\r\n    private clientId: string;\r\n    private cacheStorage: CacheManager;\r\n    private cryptoObj: ICrypto;\r\n    private logger: Logger;\r\n    private homeAccountIdentifier: string;\r\n    private serializableCache: ISerializableTokenCache | null;\r\n    private persistencePlugin: ICachePlugin | null;\r\n    private performanceClient?: IPerformanceClient;\r\n\r\n    constructor(clientId: string, cacheStorage: CacheManager, cryptoObj: ICrypto, logger: Logger, serializableCache: ISerializableTokenCache | null, persistencePlugin: ICachePlugin | null, performanceClient?: IPerformanceClient) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n        this.performanceClient = performanceClient;\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param cachedState\r\n     * @param cryptoObj\r\n     */\r\n    validateServerAuthorizationCodeResponse(serverResponseHash: ServerAuthorizationCodeResponse, cachedState: string, cryptoObj: ICrypto): void {\r\n\r\n        if (!serverResponseHash.state || !cachedState) {\r\n            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\r\n        }\r\n\r\n        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\r\n            throw ClientAuthError.createStateMismatchError();\r\n        }\r\n\r\n        // Check for error\r\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\r\n                throw new InteractionRequiredAuthError(\r\n                    serverResponseHash.error || Constants.EMPTY_STRING,\r\n                    serverResponseHash.error_description,\r\n                    serverResponseHash.suberror,\r\n                    serverResponseHash.timestamp || Constants.EMPTY_STRING,\r\n                    serverResponseHash.trace_id || Constants.EMPTY_STRING,\r\n                    serverResponseHash.correlation_id || Constants.EMPTY_STRING,\r\n                    serverResponseHash.claims || Constants.EMPTY_STRING,\r\n                );\r\n            }\r\n\r\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n        }\r\n\r\n        if (serverResponseHash.client_info) {\r\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     */\r\n    validateTokenResponse(serverResponse: ServerAuthorizationTokenResponse): void {\r\n        // Check for error\r\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError(\r\n                    serverResponse.error,\r\n                    serverResponse.error_description,\r\n                    serverResponse.suberror,\r\n                    serverResponse.timestamp || Constants.EMPTY_STRING,\r\n                    serverResponse.trace_id || Constants.EMPTY_STRING,\r\n                    serverResponse.correlation_id || Constants.EMPTY_STRING,\r\n                    serverResponse.claims || Constants.EMPTY_STRING,\r\n                );\r\n            }\r\n\r\n            const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\r\n            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    async handleServerTokenResponse(\r\n        serverTokenResponse: ServerAuthorizationTokenResponse,\r\n        authority: Authority,\r\n        reqTimestamp: number,\r\n        request: BaseAuthRequest,\r\n        authCodePayload?: AuthorizationCodePayload,\r\n        userAssertionHash?: string,\r\n        handlingRefreshTokenResponse?: boolean,\r\n        forceCacheRefreshTokenResponse?: boolean,\r\n        serverRequestId?: string): Promise<AuthenticationResult> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\r\n\r\n        // create an idToken object (not entity)\r\n        let idTokenObj: AuthToken | undefined;\r\n        if (serverTokenResponse.id_token) {\r\n            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\r\n\r\n            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\r\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\r\n                    throw ClientAuthError.createNonceMismatchError();\r\n                }\r\n            }\r\n\r\n            // token max_age check\r\n            if (request.maxAge || (request.maxAge === 0)) {\r\n                const authTime = idTokenObj.claims.auth_time;\r\n                if (!authTime) {\r\n                    throw ClientAuthError.createAuthTimeNotFoundError();\r\n                }\r\n\r\n                AuthToken.checkMaxAge(authTime, request.maxAge);\r\n            }\r\n        }\r\n\r\n        // generate homeAccountId\r\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj?.claims);\r\n\r\n        // save the response tokens\r\n        let requestStateObj: RequestStateObject | undefined;\r\n        if (!!authCodePayload && !!authCodePayload.state) {\r\n            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\r\n        }\r\n\r\n        // Add keyId from request to serverTokenResponse if defined\r\n        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\r\n\r\n        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistencePlugin && this.serializableCache) {\r\n                this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\r\n                cacheContext = new TokenCacheContext(this.serializableCache, true);\r\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\r\n            }\r\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\r\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\r\n                const key = cacheRecord.account.generateAccountKey();\r\n                const account = this.cacheStorage.getAccount(key);\r\n                if (!account) {\r\n                    this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\r\n                    return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId);\r\n                }\r\n            }\r\n            await this.cacheStorage.saveCacheRecord(cacheRecord);\r\n        } finally {\r\n            if (this.persistencePlugin && this.serializableCache && cacheContext) {\r\n                this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\r\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n        return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId);\r\n    }\r\n\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    private generateCacheRecord(serverTokenResponse: ServerAuthorizationTokenResponse, authority: Authority, reqTimestamp: number, request: BaseAuthRequest, idTokenObj?: AuthToken, userAssertionHash?: string, authCodePayload?: AuthorizationCodePayload): CacheRecord {\r\n        const env = authority.getPreferredCache();\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        let cachedIdToken: IdTokenEntity | undefined;\r\n        let cachedAccount: AccountEntity | undefined;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\r\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.id_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                idTokenObj.claims.tid || Constants.EMPTY_STRING,\r\n            );\r\n\r\n            cachedAccount = AccountEntity.createAccount(\r\n                {\r\n                    homeAccountId: this.homeAccountIdentifier,\r\n                    idTokenClaims: idTokenObj.claims,\r\n                    clientInfo: serverTokenResponse.client_info || Constants.EMPTY_STRING,\r\n                    cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\r\n                    msGraphHost: authCodePayload?.msgraph_host,\r\n                },\r\n                authority\r\n            );\r\n        }\r\n\r\n        // AccessToken\r\n        let cachedAccessToken: AccessTokenEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\r\n\r\n            // If scopes not returned in server response, use request scopes\r\n            const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\r\n\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            const expiresIn: number = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\r\n            const extExpiresIn: number = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\r\n            const refreshIn: number | undefined = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\r\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\r\n            const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\r\n\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.access_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant,\r\n                responseScopes.printScopes(),\r\n                tokenExpirationSeconds,\r\n                extendedTokenExpirationSeconds,\r\n                this.cryptoObj,\r\n                refreshOnSeconds,\r\n                serverTokenResponse.token_type,\r\n                userAssertionHash,\r\n                serverTokenResponse.key_id,\r\n                request.claims,\r\n                request.requestedClaimsHash\r\n            );\r\n        }\r\n\r\n        // refreshToken\r\n        let cachedRefreshToken: RefreshTokenEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\r\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.refresh_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                serverTokenResponse.foci,\r\n                userAssertionHash\r\n            );\r\n        }\r\n\r\n        // appMetadata\r\n        let cachedAppMetadata: AppMetadataEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\r\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\r\n        }\r\n\r\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\r\n    }\r\n\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    static async generateAuthenticationResult(\r\n        cryptoObj: ICrypto,\r\n        authority: Authority,\r\n        cacheRecord: CacheRecord,\r\n        fromTokenCache: boolean,\r\n        request: BaseAuthRequest,\r\n        idTokenObj?: AuthToken,\r\n        requestState?: RequestStateObject,\r\n        serverTokenResponse?: ServerAuthorizationTokenResponse,\r\n        requestId?: string,\r\n    ): Promise<AuthenticationResult> {\r\n        let accessToken: string = Constants.EMPTY_STRING;\r\n        let responseScopes: Array<string> = [];\r\n        let expiresOn: Date | null = null;\r\n        let extExpiresOn: Date | undefined;\r\n        let familyId: string = Constants.EMPTY_STRING;\r\n\r\n        if (cacheRecord.accessToken) {\r\n            if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\r\n                const popTokenGenerator: PopTokenGenerator = new PopTokenGenerator(cryptoObj);\r\n                const { secret, keyId } = cacheRecord.accessToken;\r\n\r\n                if (!keyId) {\r\n                    throw ClientAuthError.createKeyIdMissingError();\r\n                }\r\n\r\n                accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);\r\n            } else {\r\n                accessToken = cacheRecord.accessToken.secret;\r\n            }\r\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\r\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\r\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\r\n        }\r\n\r\n        if (cacheRecord.appMetadata) {\r\n            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\r\n        }\r\n        const uid = idTokenObj?.claims.oid || idTokenObj?.claims.sub || Constants.EMPTY_STRING;\r\n        const tid = idTokenObj?.claims.tid || Constants.EMPTY_STRING;\r\n\r\n        // for hybrid + native bridge enablement, send back the native account Id\r\n        if(serverTokenResponse?.spa_accountid && !!cacheRecord.account){\r\n            cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;\r\n        }\r\n\r\n        return {\r\n            authority: authority.canonicalAuthority,\r\n            uniqueId: uid,\r\n            tenantId: tid,\r\n            scopes: responseScopes,\r\n            account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\r\n            idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\r\n            idTokenClaims: idTokenObj ? idTokenObj.claims : {},\r\n            accessToken: accessToken,\r\n            fromCache: fromTokenCache,\r\n            expiresOn: expiresOn,\r\n            correlationId: request.correlationId,\r\n            requestId: requestId || Constants.EMPTY_STRING,\r\n            extExpiresOn: extExpiresOn,\r\n            familyId: familyId,\r\n            tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\r\n            state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\r\n            cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,\r\n            msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\r\n            code: serverTokenResponse?.spa_code,\r\n            fromNativeBroker: false,\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}