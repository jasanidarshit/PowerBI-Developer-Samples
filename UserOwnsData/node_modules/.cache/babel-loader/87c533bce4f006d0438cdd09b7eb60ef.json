{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __awaiter, __generator } from '../../_virtual/_tslib.js';\nimport { NativeConstants, NativeExtensionMethod } from '../../utils/BrowserConstants.js';\nimport { AuthError, AuthenticationScheme, PerformanceEvents } from '@azure/msal-common';\nimport { NativeAuthError } from '../../error/NativeAuthError.js';\nimport { BrowserAuthError } from '../../error/BrowserAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar NativeMessageHandler =\n/** @class */\nfunction () {\n  function NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, extensionId) {\n    this.logger = logger;\n    this.handshakeTimeoutMs = handshakeTimeoutMs;\n    this.extensionId = extensionId;\n    this.resolvers = new Map(); // Used for non-handshake messages\n\n    this.handshakeResolvers = new Map(); // Used for handshake messages\n\n    this.responseId = 0;\n    this.messageChannel = new MessageChannel();\n    this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\n\n    this.performanceClient = performanceClient;\n    this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);\n  }\n  /**\r\n   * Sends a given message to the extension and resolves with the extension response\r\n   * @param body\r\n   */\n\n\n  NativeMessageHandler.prototype.sendMessage = function (body) {\n    return __awaiter(this, void 0, void 0, function () {\n      var req;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\n        req = {\n          channel: NativeConstants.CHANNEL_ID,\n          extensionId: this.extensionId,\n          responseId: this.responseId++,\n          body: body\n        };\n        this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\n        this.logger.tracePii(\"NativeMessageHandler - Sending request to browser extension: \" + JSON.stringify(req));\n        this.messageChannel.port1.postMessage(req);\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          _this.resolvers.set(req.responseId, {\n            resolve: resolve,\n            reject: reject\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Returns an instance of the MessageHandler that has successfully established a connection with an extension\r\n   * @param {Logger} logger\r\n   * @param {number} handshakeTimeoutMs\r\n   * @param {IPerformanceClient} performanceClient\r\n   */\n\n\n  NativeMessageHandler.createProvider = function (logger, handshakeTimeoutMs, performanceClient) {\n    return __awaiter(this, void 0, void 0, function () {\n      var preferredProvider, backupProvider;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.trace(\"NativeMessageHandler - createProvider called.\");\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 5]);\n\n            preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, NativeConstants.PREFERRED_EXTENSION_ID);\n            return [4\n            /*yield*/\n            , preferredProvider.sendHandshakeRequest()];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , preferredProvider];\n\n          case 3:\n            _a.sent();\n\n            backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient);\n            return [4\n            /*yield*/\n            , backupProvider.sendHandshakeRequest()];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , backupProvider];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Send handshake request helper.\r\n   */\n\n\n  NativeMessageHandler.prototype.sendHandshakeRequest = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var req;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        this.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\"); // Register this event listener before sending handshake\n\n        window.addEventListener(\"message\", this.windowListener, false); // false is important, because content script message processing should work first\n\n        req = {\n          channel: NativeConstants.CHANNEL_ID,\n          extensionId: this.extensionId,\n          responseId: this.responseId++,\n          body: {\n            method: NativeExtensionMethod.HandshakeRequest\n          }\n        };\n        this.handshakeEvent.addStaticFields({\n          extensionId: this.extensionId,\n          extensionHandshakeTimeoutMs: this.handshakeTimeoutMs\n        });\n\n        this.messageChannel.port1.onmessage = function (event) {\n          _this.onChannelMessage(event);\n        };\n\n        window.postMessage(req, window.origin, [this.messageChannel.port2]);\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          _this.handshakeResolvers.set(req.responseId, {\n            resolve: resolve,\n            reject: reject\n          });\n\n          _this.timeoutId = window.setTimeout(function () {\n            /*\r\n             * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\r\n             * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\r\n             */\n            window.removeEventListener(\"message\", _this.windowListener, false);\n\n            _this.messageChannel.port1.close();\n\n            _this.messageChannel.port2.close();\n\n            _this.handshakeEvent.endMeasurement({\n              extensionHandshakeTimedOut: true,\n              success: false\n            });\n\n            reject(BrowserAuthError.createNativeHandshakeTimeoutError());\n\n            _this.handshakeResolvers.delete(req.responseId);\n          }, _this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\n        })];\n      });\n    });\n  };\n  /**\r\n   * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\r\n   * @param event\r\n   */\n\n\n  NativeMessageHandler.prototype.onWindowMessage = function (event) {\n    this.logger.trace(\"NativeMessageHandler - onWindowMessage called\"); // We only accept messages from ourselves\n\n    if (event.source !== window) {\n      return;\n    }\n\n    var request = event.data;\n\n    if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {\n      return;\n    }\n\n    if (request.extensionId && request.extensionId !== this.extensionId) {\n      return;\n    }\n\n    if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\n      // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\n      this.logger.verbose(request.extensionId ? \"Extension with id: \" + request.extensionId + \" not installed\" : \"No extension installed\");\n      clearTimeout(this.timeoutId);\n      this.messageChannel.port1.close();\n      this.messageChannel.port2.close();\n      window.removeEventListener(\"message\", this.windowListener, false);\n      var handshakeResolver = this.handshakeResolvers.get(request.responseId);\n\n      if (handshakeResolver) {\n        this.handshakeEvent.endMeasurement({\n          success: false,\n          extensionInstalled: false\n        });\n        handshakeResolver.reject(BrowserAuthError.createNativeExtensionNotInstalledError());\n      }\n    }\n  };\n  /**\r\n   * Invoked when a message is received from the extension on the MessageChannel port\r\n   * @param event\r\n   */\n\n\n  NativeMessageHandler.prototype.onChannelMessage = function (event) {\n    this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\n    var request = event.data;\n    var resolver = this.resolvers.get(request.responseId);\n    var handshakeResolver = this.handshakeResolvers.get(request.responseId);\n\n    try {\n      var method = request.body.method;\n\n      if (method === NativeExtensionMethod.Response) {\n        if (!resolver) {\n          return;\n        }\n\n        var response = request.body.response;\n        this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\n        this.logger.tracePii(\"NativeMessageHandler - Received response from browser extension: \" + JSON.stringify(response));\n\n        if (response.status !== \"Success\") {\n          resolver.reject(NativeAuthError.createError(response.code, response.description, response.ext));\n        } else if (response.result) {\n          if (response.result[\"code\"] && response.result[\"description\"]) {\n            resolver.reject(NativeAuthError.createError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\n          } else {\n            resolver.resolve(response.result);\n          }\n        } else {\n          throw AuthError.createUnexpectedError(\"Event does not contain result.\");\n        }\n\n        this.resolvers.delete(request.responseId);\n      } else if (method === NativeExtensionMethod.HandshakeResponse) {\n        if (!handshakeResolver) {\n          return;\n        }\n\n        clearTimeout(this.timeoutId); // Clear setTimeout\n\n        window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\n\n        this.extensionId = request.extensionId;\n        this.extensionVersion = request.body.version;\n        this.logger.verbose(\"NativeMessageHandler - Received HandshakeResponse from extension: \" + this.extensionId);\n        this.handshakeEvent.endMeasurement({\n          extensionInstalled: true,\n          success: true\n        });\n        handshakeResolver.resolve();\n        this.handshakeResolvers.delete(request.responseId);\n      } // Do nothing if method is not Response or HandshakeResponse\n\n    } catch (err) {\n      this.logger.error(\"Error parsing response from WAM Extension\");\n      this.logger.errorPii(\"Error parsing response from WAM Extension: \" + err.toString());\n      this.logger.errorPii(\"Unable to parse \" + event);\n\n      if (resolver) {\n        resolver.reject(err);\n      } else if (handshakeResolver) {\n        handshakeResolver.reject(err);\n      }\n    }\n  };\n  /**\r\n   * Returns the Id for the browser extension this handler is communicating with\r\n   * @returns\r\n   */\n\n\n  NativeMessageHandler.prototype.getExtensionId = function () {\n    return this.extensionId;\n  };\n  /**\r\n   * Returns the version for the browser extension this handler is communicating with\r\n   * @returns\r\n   */\n\n\n  NativeMessageHandler.prototype.getExtensionVersion = function () {\n    return this.extensionVersion;\n  };\n  /**\r\n   * Returns boolean indicating whether or not the request should attempt to use native broker\r\n   * @param logger\r\n   * @param config\r\n   * @param nativeExtensionProvider\r\n   * @param authenticationScheme\r\n   */\n\n\n  NativeMessageHandler.isNativeAvailable = function (config, logger, nativeExtensionProvider, authenticationScheme) {\n    logger.trace(\"isNativeAvailable called\");\n\n    if (!config.system.allowNativeBroker) {\n      logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\"); // Developer disabled WAM\n\n      return false;\n    }\n\n    if (!nativeExtensionProvider) {\n      logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\"); // Extension is not available\n\n      return false;\n    }\n\n    if (authenticationScheme) {\n      switch (authenticationScheme) {\n        case AuthenticationScheme.BEARER:\n        case AuthenticationScheme.POP:\n          logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\n          return true;\n\n        default:\n          logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\n          return false;\n      }\n    }\n\n    return true;\n  };\n\n  return NativeMessageHandler;\n}();\n\nexport { NativeMessageHandler };","map":{"version":3,"sources":["../../../src/broker/nativeBroker/NativeMessageHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { NativeConstants, NativeExtensionMethod } from \"../../utils/BrowserConstants\";\r\nimport {\r\n    Logger,\r\n    AuthError,\r\n    AuthenticationScheme,\r\n    InProgressPerformanceEvent,\r\n    PerformanceEvents,\r\n    IPerformanceClient\r\n} from \"@azure/msal-common\";\r\nimport { NativeExtensionRequest, NativeExtensionRequestBody } from \"./NativeRequest\";\r\nimport { NativeAuthError } from \"../../error/NativeAuthError\";\r\nimport { BrowserAuthError } from \"../../error/BrowserAuthError\";\r\nimport { BrowserConfiguration } from \"../../config/Configuration\";\r\n\r\ntype ResponseResolvers<T> = {\r\n    resolve: (value:T|PromiseLike<T>) => void;\r\n    reject: (value:AuthError|Error|PromiseLike<Error>|PromiseLike<AuthError>)  => void;\r\n};\r\n\r\nexport class NativeMessageHandler {\r\n    private extensionId: string | undefined;\r\n    private extensionVersion: string | undefined;\r\n    private logger: Logger;\r\n    private readonly handshakeTimeoutMs: number;\r\n    private responseId: number;\r\n    private timeoutId: number | undefined;\r\n    private resolvers: Map<number, ResponseResolvers<object>>;\r\n    private handshakeResolvers: Map<number, ResponseResolvers<void>>;\r\n    private messageChannel: MessageChannel;\r\n    private readonly windowListener: (event: MessageEvent) => void;\r\n    private readonly performanceClient: IPerformanceClient;\r\n    private readonly handshakeEvent: InProgressPerformanceEvent;\r\n\r\n    constructor(logger: Logger, handshakeTimeoutMs: number, performanceClient: IPerformanceClient, extensionId?: string) {\r\n        this.logger = logger;\r\n        this.handshakeTimeoutMs = handshakeTimeoutMs;\r\n        this.extensionId = extensionId;\r\n        this.resolvers = new Map(); // Used for non-handshake messages\r\n        this.handshakeResolvers = new Map(); // Used for handshake messages\r\n        this.responseId = 0;\r\n        this.messageChannel = new MessageChannel();\r\n        this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\r\n        this.performanceClient = performanceClient;\r\n        this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);\r\n    }\r\n\r\n    /**\r\n     * Sends a given message to the extension and resolves with the extension response\r\n     * @param body\r\n     */\r\n    async sendMessage(body: NativeExtensionRequestBody): Promise<object> {\r\n        this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\r\n        const req: NativeExtensionRequest = {\r\n            channel: NativeConstants.CHANNEL_ID,\r\n            extensionId: this.extensionId,\r\n            responseId: this.responseId++,\r\n            body: body\r\n        };\r\n\r\n        this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\r\n        this.logger.tracePii(`NativeMessageHandler - Sending request to browser extension: ${JSON.stringify(req)}`);\r\n        this.messageChannel.port1.postMessage(req);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.resolvers.set(req.responseId, {resolve, reject});\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns an instance of the MessageHandler that has successfully established a connection with an extension\r\n     * @param {Logger} logger\r\n     * @param {number} handshakeTimeoutMs\r\n     * @param {IPerformanceClient} performanceClient\r\n     */\r\n    static async createProvider(logger: Logger, handshakeTimeoutMs: number, performanceClient: IPerformanceClient): Promise<NativeMessageHandler> {\r\n        logger.trace(\"NativeMessageHandler - createProvider called.\");\r\n        try {\r\n            const preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, NativeConstants.PREFERRED_EXTENSION_ID);\r\n            await preferredProvider.sendHandshakeRequest();\r\n            return preferredProvider;\r\n        } catch (e) {\r\n            // If preferred extension fails for whatever reason, fallback to using any installed extension\r\n            const backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient);\r\n            await backupProvider.sendHandshakeRequest();\r\n            return backupProvider;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send handshake request helper.\r\n     */\r\n    private async sendHandshakeRequest(): Promise<void> {\r\n        this.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\");\r\n        // Register this event listener before sending handshake\r\n        window.addEventListener(\"message\", this.windowListener, false); // false is important, because content script message processing should work first\r\n\r\n        const req: NativeExtensionRequest = {\r\n            channel: NativeConstants.CHANNEL_ID,\r\n            extensionId: this.extensionId,\r\n            responseId: this.responseId++,\r\n            body: {\r\n                method: NativeExtensionMethod.HandshakeRequest\r\n            }\r\n        };\r\n        this.handshakeEvent.addStaticFields({\r\n            extensionId: this.extensionId,\r\n            extensionHandshakeTimeoutMs: this.handshakeTimeoutMs\r\n        });\r\n\r\n        this.messageChannel.port1.onmessage = (event) => {\r\n            this.onChannelMessage(event);\r\n        };\r\n\r\n        window.postMessage(req, window.origin, [this.messageChannel.port2]);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.handshakeResolvers.set(req.responseId, {resolve, reject});\r\n            this.timeoutId = window.setTimeout(() => {\r\n                /*\r\n                 * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\r\n                 * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\r\n                 */\r\n                window.removeEventListener(\"message\", this.windowListener, false);\r\n                this.messageChannel.port1.close();\r\n                this.messageChannel.port2.close();\r\n                this.handshakeEvent.endMeasurement({extensionHandshakeTimedOut: true, success: false});\r\n                reject(BrowserAuthError.createNativeHandshakeTimeoutError());\r\n                this.handshakeResolvers.delete(req.responseId);\r\n            }, this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\r\n     * @param event\r\n     */\r\n    private onWindowMessage(event: MessageEvent): void {\r\n        this.logger.trace(\"NativeMessageHandler - onWindowMessage called\");\r\n        // We only accept messages from ourselves\r\n        if (event.source !== window) {\r\n            return;\r\n        }\r\n\r\n        const request = event.data;\r\n\r\n        if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {\r\n            return;\r\n        }\r\n\r\n        if (request.extensionId && request.extensionId !== this.extensionId) {\r\n            return;\r\n        }\r\n\r\n        if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\r\n            // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\r\n            this.logger.verbose(request.extensionId ? `Extension with id: ${request.extensionId} not installed` : \"No extension installed\");\r\n            clearTimeout(this.timeoutId);\r\n            this.messageChannel.port1.close();\r\n            this.messageChannel.port2.close();\r\n            window.removeEventListener(\"message\", this.windowListener, false);\r\n            const handshakeResolver = this.handshakeResolvers.get(request.responseId);\r\n            if (handshakeResolver) {\r\n                this.handshakeEvent.endMeasurement({success: false, extensionInstalled: false});\r\n                handshakeResolver.reject(BrowserAuthError.createNativeExtensionNotInstalledError());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Invoked when a message is received from the extension on the MessageChannel port\r\n     * @param event\r\n     */\r\n    private onChannelMessage(event: MessageEvent): void {\r\n        this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\r\n        const request = event.data;\r\n\r\n        const resolver = this.resolvers.get(request.responseId);\r\n        const handshakeResolver = this.handshakeResolvers.get(request.responseId);\r\n\r\n        try {\r\n            const method = request.body.method;\r\n\r\n            if (method === NativeExtensionMethod.Response) {\r\n                if (!resolver) {\r\n                    return;\r\n                }\r\n                const response = request.body.response;\r\n                this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\r\n                this.logger.tracePii(`NativeMessageHandler - Received response from browser extension: ${JSON.stringify(response)}`);\r\n                if (response.status !== \"Success\") {\r\n                    resolver.reject(NativeAuthError.createError(response.code, response.description, response.ext));\r\n                } else if (response.result) {\r\n                    if (response.result[\"code\"] && response.result[\"description\"]) {\r\n                        resolver.reject(NativeAuthError.createError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\r\n                    } else {\r\n                        resolver.resolve(response.result);\r\n                    }\r\n                } else {\r\n                    throw AuthError.createUnexpectedError(\"Event does not contain result.\");\r\n                }\r\n                this.resolvers.delete(request.responseId);\r\n            } else if (method === NativeExtensionMethod.HandshakeResponse) {\r\n                if (!handshakeResolver) {\r\n                    return;\r\n                }\r\n                clearTimeout(this.timeoutId); // Clear setTimeout\r\n                window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\r\n                this.extensionId = request.extensionId;\r\n                this.extensionVersion = request.body.version;\r\n                this.logger.verbose(`NativeMessageHandler - Received HandshakeResponse from extension: ${this.extensionId}`);\r\n                this.handshakeEvent.endMeasurement({extensionInstalled: true, success: true});\r\n\r\n                handshakeResolver.resolve();\r\n                this.handshakeResolvers.delete(request.responseId);\r\n            }\r\n            // Do nothing if method is not Response or HandshakeResponse\r\n        } catch (err) {\r\n            this.logger.error(\"Error parsing response from WAM Extension\");\r\n            this.logger.errorPii(`Error parsing response from WAM Extension: ${err.toString()}`);\r\n            this.logger.errorPii(`Unable to parse ${event}`);\r\n\r\n            if (resolver) {\r\n                resolver.reject(err as AuthError);\r\n            } else if (handshakeResolver) {\r\n                handshakeResolver.reject(err as AuthError);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the Id for the browser extension this handler is communicating with\r\n     * @returns\r\n     */\r\n    getExtensionId(): string | undefined {\r\n        return this.extensionId;\r\n    }\r\n\r\n    /**\r\n     * Returns the version for the browser extension this handler is communicating with\r\n     * @returns\r\n     */\r\n    getExtensionVersion(): string | undefined {\r\n        return this.extensionVersion;\r\n    }\r\n\r\n    /**\r\n     * Returns boolean indicating whether or not the request should attempt to use native broker\r\n     * @param logger\r\n     * @param config\r\n     * @param nativeExtensionProvider\r\n     * @param authenticationScheme\r\n     */\r\n    static isNativeAvailable(config: BrowserConfiguration, logger: Logger, nativeExtensionProvider?: NativeMessageHandler, authenticationScheme?: AuthenticationScheme): boolean {\r\n        logger.trace(\"isNativeAvailable called\");\r\n        if (!config.system.allowNativeBroker) {\r\n            logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\");\r\n            // Developer disabled WAM\r\n            return false;\r\n        }\r\n\r\n        if (!nativeExtensionProvider) {\r\n            logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\");\r\n            // Extension is not available\r\n            return false;\r\n        }\r\n\r\n        if (authenticationScheme) {\r\n            switch(authenticationScheme) {\r\n                case AuthenticationScheme.BEARER:\r\n                case AuthenticationScheme.POP:\r\n                    logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\r\n                    return true;\r\n                default:\r\n                    logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}