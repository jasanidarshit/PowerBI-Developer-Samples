{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { PerformanceEvents, StringUtils, Constants, UrlString } from '@azure/msal-common';\nimport { InteractionHandler } from './InteractionHandler.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from '../config/Configuration.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar SilentHandler =\n/** @class */\nfunction (_super) {\n  __extends(SilentHandler, _super);\n\n  function SilentHandler(authCodeModule, storageImpl, authCodeRequest, logger, systemOptions, performanceClient) {\n    var _this = _super.call(this, authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) || this;\n\n    _this.navigateFrameWait = systemOptions.navigateFrameWait;\n    _this.pollIntervalMilliseconds = systemOptions.pollIntervalMilliseconds;\n    return _this;\n  }\n  /**\r\n   * Creates a hidden iframe to given URL using user-requested scopes as an id.\r\n   * @param urlNavigate\r\n   * @param userRequestScopes\r\n   */\n\n\n  SilentHandler.prototype.initiateAuthRequest = function (requestUrl) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, this.authCodeRequest.correlationId);\n\n            if (StringUtils.isEmpty(requestUrl)) {\n              // Throw error if request URL is empty.\n              this.logger.info(\"Navigate url is empty\");\n              throw BrowserAuthError.createEmptyNavigationUriError();\n            }\n\n            if (!this.navigateFrameWait) return [3\n            /*break*/\n            , 2];\n            this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);\n            return [4\n            /*yield*/\n            , this.loadFrame(requestUrl)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            return [2\n            /*return*/\n            , this.loadFrameSync(requestUrl)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\r\n   * @param iframe\r\n   * @param timeout\r\n   */\n\n\n  SilentHandler.prototype.monitorIframeForHash = function (iframe, timeout) {\n    var _this = this;\n\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, this.authCodeRequest.correlationId);\n    return new Promise(function (resolve, reject) {\n      if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n        _this.logger.warning(\"system.loadFrameTimeout or system.iframeHashTimeout set to lower (\" + timeout + \"ms) than the default (\" + DEFAULT_IFRAME_TIMEOUT_MS + \"ms). This may result in timeouts.\");\n      }\n      /*\r\n       * Polling for iframes can be purely timing based,\r\n       * since we don't need to account for interaction.\r\n       */\n\n\n      var nowMark = window.performance.now();\n      var timeoutMark = nowMark + timeout;\n      var intervalId = setInterval(function () {\n        if (window.performance.now() > timeoutMark) {\n          _this.removeHiddenIframe(iframe);\n\n          clearInterval(intervalId);\n          reject(BrowserAuthError.createMonitorIframeTimeoutError());\n          return;\n        }\n\n        var href = Constants.EMPTY_STRING;\n        var contentWindow = iframe.contentWindow;\n\n        try {\n          /*\r\n           * Will throw if cross origin,\r\n           * which should be caught and ignored\r\n           * since we need the interval to keep running while on STS UI.\r\n           */\n          href = contentWindow ? contentWindow.location.href : Constants.EMPTY_STRING;\n        } catch (e) {}\n\n        if (StringUtils.isEmpty(href)) {\n          return;\n        }\n\n        var contentHash = contentWindow ? contentWindow.location.hash : Constants.EMPTY_STRING;\n\n        if (UrlString.hashContainsKnownProperties(contentHash)) {\n          // Success case\n          _this.removeHiddenIframe(iframe);\n\n          clearInterval(intervalId);\n          resolve(contentHash);\n          return;\n        }\n      }, _this.pollIntervalMilliseconds);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Loads iframe with authorization endpoint URL\r\n   * @ignore\r\n   */\n\n\n  SilentHandler.prototype.loadFrame = function (urlNavigate) {\n    var _this = this;\n\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);\n    /*\r\n     * This trick overcomes iframe navigation in IE\r\n     * IE does not load the page consistently in iframe\r\n     */\n\n    return new Promise(function (resolve, reject) {\n      var frameHandle = _this.createHiddenIframe();\n\n      setTimeout(function () {\n        if (!frameHandle) {\n          reject(\"Unable to load iframe\");\n          return;\n        }\n\n        frameHandle.src = urlNavigate;\n        resolve(frameHandle);\n      }, _this.navigateFrameWait);\n    });\n  };\n  /**\r\n   * @hidden\r\n   * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\r\n   * @param urlNavigate\r\n   * @param frameName\r\n   * @param logger\r\n   */\n\n\n  SilentHandler.prototype.loadFrameSync = function (urlNavigate) {\n    var frameHandle = this.createHiddenIframe();\n    frameHandle.src = urlNavigate;\n    return frameHandle;\n  };\n  /**\r\n   * @hidden\r\n   * Creates a new hidden iframe or gets an existing one for silent token renewal.\r\n   * @ignore\r\n   */\n\n\n  SilentHandler.prototype.createHiddenIframe = function () {\n    var authFrame = document.createElement(\"iframe\");\n    authFrame.className = \"msalSilentIframe\";\n    authFrame.style.visibility = \"hidden\";\n    authFrame.style.position = \"absolute\";\n    authFrame.style.width = authFrame.style.height = \"0\";\n    authFrame.style.border = \"0\";\n    authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n    document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\n    return authFrame;\n  };\n  /**\r\n   * @hidden\r\n   * Removes a hidden iframe from the page.\r\n   * @ignore\r\n   */\n\n\n  SilentHandler.prototype.removeHiddenIframe = function (iframe) {\n    if (document.body === iframe.parentNode) {\n      document.body.removeChild(iframe);\n    }\n  };\n\n  return SilentHandler;\n}(InteractionHandler);\n\nexport { SilentHandler };","map":{"version":3,"sources":["../../src/interaction_handler/SilentHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { UrlString, StringUtils, CommonAuthorizationCodeRequest, AuthorizationCodeClient, Constants, Logger, IPerformanceClient, PerformanceEvents } from \"@azure/msal-common\";\r\nimport { InteractionHandler } from \"./InteractionHandler\";\r\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\r\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\r\nimport { BrowserSystemOptions, DEFAULT_IFRAME_TIMEOUT_MS } from \"../config/Configuration\";\r\n\r\nexport class SilentHandler extends InteractionHandler {\r\n\r\n    private navigateFrameWait: number;\r\n    private pollIntervalMilliseconds: number;\r\n\r\n    constructor(authCodeModule: AuthorizationCodeClient, storageImpl: BrowserCacheManager, authCodeRequest: CommonAuthorizationCodeRequest, logger: Logger, systemOptions: Required<Pick<BrowserSystemOptions, \"navigateFrameWait\" | \"pollIntervalMilliseconds\">>, performanceClient: IPerformanceClient) {\r\n        super(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient);\r\n        this.navigateFrameWait = systemOptions.navigateFrameWait;\r\n        this.pollIntervalMilliseconds = systemOptions.pollIntervalMilliseconds;\r\n    }\r\n\r\n    /**\r\n     * Creates a hidden iframe to given URL using user-requested scopes as an id.\r\n     * @param urlNavigate\r\n     * @param userRequestScopes\r\n     */\r\n    async initiateAuthRequest(requestUrl: string): Promise<HTMLIFrameElement> {\r\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, this.authCodeRequest.correlationId);\r\n\r\n        if (StringUtils.isEmpty(requestUrl)) {\r\n            // Throw error if request URL is empty.\r\n            this.logger.info(\"Navigate url is empty\");\r\n            throw BrowserAuthError.createEmptyNavigationUriError();\r\n        }\r\n\r\n        if (this.navigateFrameWait) {\r\n            this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);\r\n            return await this.loadFrame(requestUrl);\r\n        }\r\n        return this.loadFrameSync(requestUrl);\r\n    }\r\n\r\n    /**\r\n     * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\r\n     * @param iframe\r\n     * @param timeout\r\n     */\r\n    monitorIframeForHash(iframe: HTMLIFrameElement, timeout: number): Promise<string> {\r\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, this.authCodeRequest.correlationId);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\r\n                this.logger.warning(`system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`);\r\n            }\r\n\r\n            /*\r\n             * Polling for iframes can be purely timing based,\r\n             * since we don't need to account for interaction.\r\n             */\r\n            const nowMark = window.performance.now();\r\n            const timeoutMark = nowMark + timeout;\r\n\r\n            const intervalId = setInterval(() => {\r\n                if (window.performance.now() > timeoutMark) {\r\n                    this.removeHiddenIframe(iframe);\r\n                    clearInterval(intervalId);\r\n                    reject(BrowserAuthError.createMonitorIframeTimeoutError());\r\n                    return;\r\n                }\r\n\r\n                let href: string = Constants.EMPTY_STRING;\r\n                const contentWindow = iframe.contentWindow;\r\n                try {\r\n                    /*\r\n                     * Will throw if cross origin,\r\n                     * which should be caught and ignored\r\n                     * since we need the interval to keep running while on STS UI.\r\n                     */\r\n                    href = contentWindow ? contentWindow.location.href : Constants.EMPTY_STRING;\r\n                } catch (e) {}\r\n\r\n                if (StringUtils.isEmpty(href)) {\r\n                    return;\r\n                }\r\n\r\n                const contentHash = contentWindow ? contentWindow.location.hash: Constants.EMPTY_STRING;\r\n                if (UrlString.hashContainsKnownProperties(contentHash)) {\r\n                    // Success case\r\n                    this.removeHiddenIframe(iframe);\r\n                    clearInterval(intervalId);\r\n                    resolve(contentHash);\r\n                    return;\r\n                }\r\n            }, this.pollIntervalMilliseconds);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads iframe with authorization endpoint URL\r\n     * @ignore\r\n     */\r\n    private loadFrame(urlNavigate: string): Promise<HTMLIFrameElement> {\r\n        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);\r\n\r\n        /*\r\n         * This trick overcomes iframe navigation in IE\r\n         * IE does not load the page consistently in iframe\r\n         */\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const frameHandle = this.createHiddenIframe();\r\n\r\n            setTimeout(() => {\r\n                if (!frameHandle) {\r\n                    reject(\"Unable to load iframe\");\r\n                    return;\r\n                }\r\n\r\n                frameHandle.src = urlNavigate;\r\n\r\n                resolve(frameHandle);\r\n            }, this.navigateFrameWait);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\r\n     * @param urlNavigate\r\n     * @param frameName\r\n     * @param logger\r\n     */\r\n    private loadFrameSync(urlNavigate: string): HTMLIFrameElement{\r\n        const frameHandle = this.createHiddenIframe();\r\n\r\n        frameHandle.src = urlNavigate;\r\n\r\n        return frameHandle;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Creates a new hidden iframe or gets an existing one for silent token renewal.\r\n     * @ignore\r\n     */\r\n    private createHiddenIframe(): HTMLIFrameElement {\r\n        const authFrame = document.createElement(\"iframe\");\r\n\r\n        authFrame.className = \"msalSilentIframe\";\r\n        authFrame.style.visibility = \"hidden\";\r\n        authFrame.style.position = \"absolute\";\r\n        authFrame.style.width = authFrame.style.height = \"0\";\r\n        authFrame.style.border = \"0\";\r\n        authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\r\n        document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\r\n\r\n        return authFrame;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Removes a hidden iframe from the page.\r\n     * @ignore\r\n     */\r\n    private removeHiddenIframe(iframe: HTMLIFrameElement): void {\r\n        if (document.body === iframe.parentNode) {\r\n            document.body.removeChild(iframe);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}