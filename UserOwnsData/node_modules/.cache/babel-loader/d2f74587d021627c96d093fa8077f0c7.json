{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { Constants } from '@azure/msal-common';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar MsBrowserCrypto =\n/** @class */\nfunction () {\n  function MsBrowserCrypto() {}\n\n  MsBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    return window[\"msCrypto\"].getRandomValues(dataBuffer);\n  };\n\n  MsBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msGenerateKey = window[\"msCrypto\"].subtle.generateKey(algorithm, extractable, keyUsages);\n          msGenerateKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msGenerateKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  MsBrowserCrypto.prototype.exportKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n          msExportKey.addEventListener(\"complete\", function (e) {\n            var resultBuffer = e.target.result;\n            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\\r/g, Constants.EMPTY_STRING).replace(/\\n/g, Constants.EMPTY_STRING).replace(/\\t/g, Constants.EMPTY_STRING).split(\" \").join(Constants.EMPTY_STRING).replace(\"\\u0000\", Constants.EMPTY_STRING);\n\n            try {\n              resolve(JSON.parse(resultString));\n            } catch (e) {\n              reject(e);\n            }\n          });\n          msExportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  MsBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keyString, keyBuffer;\n      return __generator(this, function (_a) {\n        keyString = BrowserStringUtils.getSortedObjectString(keyData);\n        keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);\n          msImportKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msImportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  MsBrowserCrypto.prototype.sign = function (algorithm, key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msSign = window[\"msCrypto\"].subtle.sign(algorithm, key, data);\n          msSign.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msSign.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  MsBrowserCrypto.prototype.digest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n          digestOperation.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          digestOperation.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n\n  return MsBrowserCrypto;\n}();\n\nexport { MsBrowserCrypto };","map":{"version":3,"sources":["../../src/crypto/MsBrowserCrypto.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Constants } from \"@azure/msal-common\";\r\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\r\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\r\nimport { ISubtleCrypto } from \"./ISubtleCrypto\";\r\n\r\nexport class MsBrowserCrypto implements ISubtleCrypto {\r\n    getRandomValues(dataBuffer: Uint8Array): Uint8Array {\r\n        return window[\"msCrypto\"].getRandomValues(dataBuffer);\r\n    }\r\n\r\n    async generateKey(algorithm: RsaHashedKeyGenParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKeyPair> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msGenerateKey = window[\"msCrypto\"].subtle.generateKey(algorithm, extractable, keyUsages);\r\n            msGenerateKey.addEventListener(\"complete\", (e: { target: { result: CryptoKeyPair | PromiseLike<CryptoKeyPair>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msGenerateKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async exportKey(key: CryptoKey): Promise<JsonWebKey> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\r\n            msExportKey.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer; }; }) => {\r\n                const resultBuffer: ArrayBuffer = e.target.result;\r\n\r\n                const resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))\r\n                    .replace(/\\r/g, Constants.EMPTY_STRING)\r\n                    .replace(/\\n/g, Constants.EMPTY_STRING)\r\n                    .replace(/\\t/g, Constants.EMPTY_STRING)\r\n                    .split(\" \").join(Constants.EMPTY_STRING)\r\n                    .replace(\"\\u0000\", Constants.EMPTY_STRING);\r\n\r\n                try {\r\n                    resolve(JSON.parse(resultString));\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n\r\n            msExportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async importKey(keyData: JsonWebKey, algorithm: RsaHashedImportParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey> {\r\n        const keyString = BrowserStringUtils.getSortedObjectString(keyData);\r\n        const keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\r\n\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);\r\n            msImportKey.addEventListener(\"complete\", (e: { target: { result: CryptoKey | PromiseLike<CryptoKey>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msImportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msSign = window[\"msCrypto\"].subtle.sign(algorithm, key, data);\r\n            msSign.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msSign.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    \r\n    async digest(algorithm: AlgorithmIdentifier, data: Uint8Array): Promise<ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            const digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\r\n            digestOperation.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n            digestOperation.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}