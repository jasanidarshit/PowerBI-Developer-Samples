{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { RegionDiscoverySources, ResponseCodes, Constants } from '../utils/Constants.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar RegionDiscovery =\n/** @class */\nfunction () {\n  function RegionDiscovery(networkInterface, performanceClient, correlationId) {\n    this.networkInterface = networkInterface;\n    this.performanceClient = performanceClient;\n    this.correlationId = correlationId;\n  }\n  /**\r\n   * Detect the region from the application's environment.\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n\n\n  RegionDiscovery.prototype.detectRegion = function (environmentRegion, regionDiscoveryMetadata) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\n            autodetectedRegionName = environmentRegion;\n            if (!!autodetectedRegionName) return [3\n            /*break*/\n            , 8];\n            options = RegionDiscovery.IMDS_OPTIONS;\n            _e.label = 1;\n\n          case 1:\n            _e.trys.push([1, 6,, 7]);\n\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n            return [4\n            /*yield*/\n            , this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];\n\n          case 2:\n            localIMDSVersionResponse = _e.sent();\n\n            if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = localIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n\n            if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest)) return [3\n            /*break*/\n            , 5];\n            (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n            return [4\n            /*yield*/\n            , this.getCurrentVersion(options)];\n\n          case 3:\n            currentIMDSVersion = _e.sent();\n\n            if (!currentIMDSVersion) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n              return [2\n              /*return*/\n              , null];\n            }\n\n            (_d = this.performanceClient) === null || _d === void 0 ? void 0 : _d.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n            return [4\n            /*yield*/\n            , this.getRegionFromIMDS(currentIMDSVersion, options)];\n\n          case 4:\n            currentIMDSVersionResponse = _e.sent();\n\n            if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n              autodetectedRegionName = currentIMDSVersionResponse.body;\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n            }\n\n            _e.label = 5;\n\n          case 5:\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            _e.sent();\n\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return [2\n            /*return*/\n            , null];\n\n          case 7:\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n            _e.label = 9;\n\n          case 9:\n            // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n            if (!autodetectedRegionName) {\n              regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            }\n\n            return [2\n            /*return*/\n            , autodetectedRegionName || null];\n        }\n      });\n    });\n  };\n  /**\r\n   * Make the call to the IMDS endpoint\r\n   *\r\n   * @param imdsEndpointUrl\r\n   * @returns Promise<NetworkResponse<string>>\r\n   */\n\n\n  RegionDiscovery.prototype.getRegionFromIMDS = function (version, options) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n        return [2\n        /*return*/\n        , this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + \"?api-version=\" + version + \"&format=text\", options, Constants.IMDS_TIMEOUT)];\n      });\n    });\n  };\n  /**\r\n   * Get the most recent version of the IMDS endpoint available\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n\n\n  RegionDiscovery.prototype.getCurrentVersion = function (options) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var response;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + \"?format=json\", options)];\n\n          case 2:\n            response = _b.sent(); // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n\n            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n              return [2\n              /*return*/\n              , response.body[\"newest-versions\"][0]];\n            }\n\n            return [2\n            /*return*/\n            , null];\n\n          case 3:\n            _b.sent();\n\n            return [2\n            /*return*/\n            , null];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Options for the IMDS endpoint request\n\n\n  RegionDiscovery.IMDS_OPTIONS = {\n    headers: {\n      Metadata: \"true\"\n    }\n  };\n  return RegionDiscovery;\n}();\n\nexport { RegionDiscovery };","map":{"version":3,"sources":["../../src/authority/RegionDiscovery.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule } from \"../network/INetworkModule\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { IMDSBadResponse } from \"../response/IMDSBadResponse\";\r\nimport { Constants, RegionDiscoverySources, ResponseCodes } from \"../utils/Constants\";\r\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\r\nimport { ImdsOptions } from \"./ImdsOptions\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\r\n\r\nexport class RegionDiscovery {\r\n    // Network interface to make requests with.\r\n    protected networkInterface: INetworkModule;\r\n    // Performance client\r\n    protected performanceClient: IPerformanceClient | undefined;\r\n    // CorrelationId\r\n    protected correlationId: string | undefined;\r\n    // Options for the IMDS endpoint request\r\n    protected static IMDS_OPTIONS: ImdsOptions = {\r\n        headers: {\r\n            Metadata: \"true\",\r\n        },\r\n    };\r\n\r\n    constructor(networkInterface: INetworkModule, performanceClient?: IPerformanceClient, correlationId?: string) {\r\n        this.networkInterface = networkInterface;\r\n        this.performanceClient = performanceClient;\r\n        this.correlationId = correlationId;\r\n    }\r\n\r\n    /**\r\n     * Detect the region from the application's environment.\r\n     * \r\n     * @returns Promise<string | null>\r\n     */\r\n    public async detectRegion(environmentRegion: string | undefined, regionDiscoveryMetadata: RegionDiscoveryMetadata): Promise<string | null> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\r\n        \r\n        // Initialize auto detected region with the region from the envrionment \r\n        let autodetectedRegionName = environmentRegion;\r\n\r\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS \r\n        if (!autodetectedRegionName) {\r\n            const options = RegionDiscovery.IMDS_OPTIONS;\r\n\r\n            try {\r\n                this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\r\n                const localIMDSVersionResponse = await this.getRegionFromIMDS(Constants.IMDS_VERSION, options);\r\n                if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\r\n                    autodetectedRegionName = localIMDSVersionResponse.body;\r\n                    regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\r\n                } \r\n                \r\n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry. \r\n                if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {\r\n                    this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\r\n                    const currentIMDSVersion = await this.getCurrentVersion(options);\r\n                    if (!currentIMDSVersion) {\r\n                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n                        return null;\r\n                    }\r\n\r\n                    this.performanceClient?.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\r\n                    const currentIMDSVersionResponse = await this.getRegionFromIMDS(currentIMDSVersion, options);\r\n                    if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\r\n                        autodetectedRegionName = currentIMDSVersionResponse.body;\r\n                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\r\n                    }\r\n                }\r\n            } catch(e) {\r\n                regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n                return null;\r\n            } \r\n        } else {\r\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\r\n        }\r\n\r\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\r\n        if (!autodetectedRegionName) {\r\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\r\n        }\r\n\r\n        return autodetectedRegionName || null;\r\n    }\r\n\r\n    /**\r\n     * Make the call to the IMDS endpoint\r\n     * \r\n     * @param imdsEndpointUrl\r\n     * @returns Promise<NetworkResponse<string>>\r\n     */\r\n    private async getRegionFromIMDS(version: string, options: ImdsOptions): Promise<NetworkResponse<string>> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\r\n        return this.networkInterface.sendGetRequestAsync<string>(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\r\n    }\r\n\r\n    /**\r\n     * Get the most recent version of the IMDS endpoint available\r\n     *  \r\n     * @returns Promise<string | null>\r\n     */\r\n    private async getCurrentVersion(options: ImdsOptions): Promise<string | null> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\r\n        try {\r\n            const response = await this.networkInterface.sendGetRequestAsync<IMDSBadResponse>(`${Constants.IMDS_ENDPOINT}?format=json`, options);\r\n\r\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\r\n            if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\r\n                return response.body[\"newest-versions\"][0];\r\n            }\r\n\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}