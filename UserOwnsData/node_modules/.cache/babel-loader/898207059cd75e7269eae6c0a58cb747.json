{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __extends, __awaiter, __spread, __generator } from '../_virtual/_tslib.js';\nimport { CredentialType, RefreshTokenEntity, CacheManager, AccessTokenEntity, IdTokenEntity, AccountEntity, ClientAuthError, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ThrottlingEntity, StringUtils, ProtocolUtils, CcsCredentialType, IdToken, CacheRecord, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\n\nvar BrowserCacheManager =\n/** @class */\nfunction (_super) {\n  __extends(BrowserCacheManager, _super);\n\n  function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\n    var _this = _super.call(this, clientId, cryptoImpl, logger) || this; // Cookie life calculation (hours * minutes * seconds * ms)\n\n\n    _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    _this.cacheConfig = cacheConfig;\n    _this.logger = logger;\n    _this.internalStorage = new MemoryStorage();\n    _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\n    _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.temporaryCacheLocation, _this.cacheConfig.cacheLocation); // Migrate cache entries from older versions of MSAL.\n\n    if (cacheConfig.cacheMigrationEnabled) {\n      _this.migrateCacheEntries();\n\n      _this.createKeyMaps();\n    }\n\n    return _this;\n  }\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n\n    }\n\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  };\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\r\n   * @param temporaryCacheLocation\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (temporaryCacheLocation, cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          /*\r\n           * When users do not explicitly choose their own temporaryCacheLocation,\r\n           * temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n           */\n          return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  };\n  /**\r\n   * Migrate all old cache entries to new schema. No rollback supported.\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntries = function () {\n    var _this = this;\n\n    var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\n    var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\n    var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\n    var idTokenValue = this.browserStorage.getItem(idTokenKey);\n    var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    var errorValue = this.browserStorage.getItem(errorKey);\n    var errorDescValue = this.browserStorage.getItem(errorDescKey);\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.migrateCacheEntry(cacheKey, values[index]);\n    });\n  };\n  /**\r\n   * Utility function to help with migration.\r\n   * @param newKey\r\n   * @param value\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  };\n  /**\r\n   * Searches all cache entries for MSAL accounts and creates the account key map\r\n   * This is used to migrate users from older versions of MSAL which did not create the map.\r\n   * @returns\r\n   */\n\n\n  BrowserCacheManager.prototype.createKeyMaps = function () {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n    var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    var tokenKeys = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\n\n    if (accountKeys && tokenKeys) {\n      this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\"); // Key maps already exist, no need to iterate through cache\n\n      return;\n    }\n\n    var allKeys = this.browserStorage.getKeys();\n    allKeys.forEach(function (key) {\n      if (_this.isCredentialKey(key)) {\n        // Get item, parse, validate and write key to map\n        var value = _this.getItem(key);\n\n        if (value) {\n          var credObj = _this.validateAndParseJson(value);\n\n          if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n            switch (credObj[\"credentialType\"]) {\n              case CredentialType.ID_TOKEN:\n                if (IdTokenEntity.isIdTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - idToken with key: \" + key + \" found, saving key to token key map\");\n\n                  var idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\n\n                  var newKey = _this.updateCredentialCacheKey(key, idTokenEntity);\n\n                  _this.addTokenKey(newKey, CredentialType.ID_TOKEN);\n\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed idToken validation on key: \" + key);\n                }\n\n                break;\n\n              case CredentialType.ACCESS_TOKEN:\n              case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - accessToken with key: \" + key + \" found, saving key to token key map\");\n\n                  var accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\n\n                  var newKey = _this.updateCredentialCacheKey(key, accessTokenEntity);\n\n                  _this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\n\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed accessToken validation on key: \" + key);\n                }\n\n                break;\n\n              case CredentialType.REFRESH_TOKEN:\n                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - refreshToken with key: \" + key + \" found, saving key to token key map\");\n\n                  var refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\n\n                  var newKey = _this.updateCredentialCacheKey(key, refreshTokenEntity);\n\n                  _this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\n\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\n\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: \" + key);\n                }\n\n                break;\n              // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n            }\n          }\n        }\n      }\n\n      if (_this.isAccountKey(key)) {\n        var value = _this.getItem(key);\n\n        if (value) {\n          var accountObj = _this.validateAndParseJson(value);\n\n          if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\n            _this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\n\n            _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - account with key: \" + key + \" found, saving key to account key map\");\n\n            _this.addAccountKeyToMap(key);\n          }\n        }\n      }\n    });\n  };\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n\n\n  BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\n    try {\n      var parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  };\n  /**\r\n   * fetches the entry from the browser storage based off the key\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getItem = function (key) {\n    return this.browserStorage.getItem(key);\n  };\n  /**\r\n   * sets the entry in the browser storage\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setItem = function (key, value) {\n    this.browserStorage.setItem(key, value);\n  };\n  /**\r\n   * fetch the account entity from the platform cache\r\n   * @param accountKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccount = function (accountKey) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    var account = this.getItem(accountKey);\n\n    if (!account) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n\n    var parsedAccount = this.validateAndParseJson(account);\n\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  };\n  /**\r\n   * set account entity in the platform cache\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccount = function (account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    var key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n    this.addAccountKeyToMap(key);\n  };\n  /**\r\n   * Returns the array of account keys currently cached\r\n   * @returns\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountKeys = function () {\n    this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n    var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n\n    if (accountKeys) {\n      return JSON.parse(accountKeys);\n    }\n\n    this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\n    return [];\n  };\n  /**\r\n   * Add a new account to the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.addAccountKeyToMap = function (key) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.addAccountKeyToMap called with key: \" + key);\n    var accountKeys = this.getAccountKeys();\n\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n    }\n  };\n  /**\r\n   * Remove an account from the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeAccountKeyFromMap = function (key) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.removeAccountKeyFromMap called with key: \" + key);\n    var accountKeys = this.getAccountKeys();\n    var removalIndex = accountKeys.indexOf(key);\n\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  };\n  /**\r\n   * Extends inherited removeAccount function to include removal of the account key from the map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeAccount = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        _super.prototype.removeAccount.call(this, key);\n\n        this.removeAccountKeyFromMap(key);\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Removes given idToken from the cache and from the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeIdToken = function (key) {\n    _super.prototype.removeIdToken.call(this, key);\n\n    this.removeTokenKey(key, CredentialType.ID_TOKEN);\n  };\n  /**\r\n   * Removes given accessToken from the cache and from the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeAccessToken = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        _super.prototype.removeAccessToken.call(this, key);\n\n        this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Removes given refreshToken from the cache and from the key map\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeRefreshToken = function (key) {\n    _super.prototype.removeRefreshToken.call(this, key);\n\n    this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n  };\n  /**\r\n   * Gets the keys for the cached tokens associated with this clientId\r\n   * @returns\r\n   */\n\n\n  BrowserCacheManager.prototype.getTokenKeys = function () {\n    this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n    var item = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\n\n    if (item) {\n      var tokenKeys = this.validateAndParseJson(item);\n\n      if (tokenKeys && tokenKeys.hasOwnProperty(\"idToken\") && tokenKeys.hasOwnProperty(\"accessToken\") && tokenKeys.hasOwnProperty(\"refreshToken\")) {\n        return tokenKeys;\n      } else {\n        this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\n      }\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\n    }\n\n    return {\n      idToken: [],\n      accessToken: [],\n      refreshToken: []\n    };\n  };\n  /**\r\n   * Adds the given key to the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n\n\n  BrowserCacheManager.prototype.addTokenKey = function (key, type) {\n    this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n    var tokenKeys = this.getTokenKeys();\n\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        if (tokenKeys.idToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n          tokenKeys.idToken.push(key);\n        }\n\n        break;\n\n      case CredentialType.ACCESS_TOKEN:\n        if (tokenKeys.accessToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\n          tokenKeys.accessToken.push(key);\n        }\n\n        break;\n\n      case CredentialType.REFRESH_TOKEN:\n        if (tokenKeys.refreshToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n          tokenKeys.refreshToken.push(key);\n        }\n\n        break;\n\n      default:\n        this.logger.error(\"BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: \" + type);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n\n    this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\n  };\n  /**\r\n   * Removes the given key from the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n\n\n  BrowserCacheManager.prototype.removeTokenKey = function (key, type) {\n    this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n    var tokenKeys = this.getTokenKeys();\n\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: \" + key + \" from map\");\n        var idRemoval = tokenKeys.idToken.indexOf(key);\n\n        if (idRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n          tokenKeys.idToken.splice(idRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n\n        break;\n\n      case CredentialType.ACCESS_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: \" + key + \" from map\");\n        var accessRemoval = tokenKeys.accessToken.indexOf(key);\n\n        if (accessRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n          tokenKeys.accessToken.splice(accessRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n\n        break;\n\n      case CredentialType.REFRESH_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: \" + key + \" from map\");\n        var refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n\n        if (refreshRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n          tokenKeys.refreshToken.splice(refreshRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n\n        break;\n\n      default:\n        this.logger.error(\"BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: \" + type);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n\n    this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\n  };\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\n    var value = this.getItem(idTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n\n    var parsedIdToken = this.validateAndParseJson(value);\n\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  };\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    var idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n    this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n  };\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\n    var value = this.getItem(accessTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n\n    var parsedAccessToken = this.validateAndParseJson(value);\n\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  };\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    var accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n    this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n  };\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\n    var value = this.getItem(refreshTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n\n    var parsedRefreshToken = this.validateAndParseJson(value);\n\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  };\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    var refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n    this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n  };\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\n    var value = this.getItem(appMetadataKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  };\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n\n\n  BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    var appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  };\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\n    var value = this.getItem(serverTelemetryKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  };\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n\n\n  BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\n    var value = this.internalStorage.getItem(key);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n\n    return null;\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\n    var _this = this;\n\n    var allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(function (key) {\n      return _this.isAuthorityMetadata(key);\n    });\n  };\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n\n\n  BrowserCacheManager.prototype.setWrapperMetadata = function (wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  };\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n\n\n  BrowserCacheManager.prototype.getWrapperMetadata = function () {\n    var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  };\n  /**\r\n   *\r\n   * @param entity\r\n   */\n\n\n  BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  };\n  /**\r\n   * Gets the active account\r\n   */\n\n\n  BrowserCacheManager.prototype.getActiveAccount = function () {\n    var activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    var activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n\n    if (!activeAccountValueFilters) {\n      // if new active account cache type isn't found, it's an old version, so look for that instead\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n      var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n      var activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n\n      if (!activeAccountValueLocal) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n      }\n\n      var activeAccount = this.getAccountInfoByFilter({\n        localAccountId: activeAccountValueLocal\n      })[0] || null;\n\n      if (activeAccount) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n        this.setActiveAccount(activeAccount);\n        return activeAccount;\n      }\n\n      return null;\n    }\n\n    var activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoByFilter({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId\n      })[0] || null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  };\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.setActiveAccount = function (account) {\n    var activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      var activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId\n      };\n      this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n      this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n      this.browserStorage.removeItem(activeAccountKeyLocal);\n    }\n  };\n  /**\r\n   * Gets a list of accounts that match all of the filters provided\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\n    var allAccounts = this.getAllAccounts();\n    this.logger.trace(\"BrowserCacheManager.getAccountInfoByFilter: total \" + allAccounts.length + \" accounts found\");\n    return allAccounts.filter(function (accountObj) {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n\n      return true;\n    });\n  };\n  /**\r\n   * Checks the cache for accounts matching loginHint or SID\r\n   * @param loginHint\r\n   * @param sid\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountInfoByHints = function (loginHint, sid) {\n    var matchingAccounts = this.getAllAccounts().filter(function (accountInfo) {\n      if (sid) {\n        var accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\n        return sid === accountSid;\n      }\n\n      if (loginHint) {\n        return loginHint === accountInfo.username;\n      }\n\n      return false;\n    });\n\n    if (matchingAccounts.length === 1) {\n      return matchingAccounts[0];\n    } else if (matchingAccounts.length > 1) {\n      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n    }\n\n    return null;\n  };\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\n    var value = this.getItem(throttlingCacheKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    var parsedThrottlingCache = this.validateAndParseJson(value);\n\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  };\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n\n\n  BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  };\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      var itemCookie = this.getItemCookie(key);\n\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n\n    var value = this.temporaryCacheStorage.getItem(key);\n\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        var item = this.browserStorage.getItem(key);\n\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  };\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  };\n  /**\r\n   * Removes the cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeItem = function (key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n  };\n  /**\r\n   * Checks whether key is in cache.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.containsKey = function (key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  };\n  /**\r\n   * Gets all keys in window.\r\n   */\n\n\n  BrowserCacheManager.prototype.getKeys = function () {\n    return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\n  };\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n\n\n  BrowserCacheManager.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Removes all accounts and their credentials\n            return [4\n            /*yield*/\n            , this.removeAllAccounts()];\n\n          case 1:\n            // Removes all accounts and their credentials\n            _a.sent();\n\n            this.removeAppMetadata(); // Removes all remaining MSAL cache items\n\n            this.getKeys().forEach(function (cacheKey) {\n              // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n              if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(_this.clientId) !== -1)) {\n                _this.removeItem(cacheKey);\n              }\n            });\n            this.internalStorage.clear();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Clears all access tokes that have claims prior to saving the current one\r\n   * @param credential\r\n   * @returns\r\n   */\n\n\n  BrowserCacheManager.prototype.clearTokensAndKeysWithClaims = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenKeys, removedAccessTokens;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"BrowserCacheManager.clearTokensAndKeysWithClaims called\");\n            tokenKeys = this.getTokenKeys();\n            removedAccessTokens = [];\n            tokenKeys.accessToken.forEach(function (key) {\n              // if the access token has claims in its key, remove the token key and the token\n              var credential = _this.getAccessTokenCredential(key);\n\n              if ((credential === null || credential === void 0 ? void 0 : credential.requestedClaimsHash) && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n                removedAccessTokens.push(_this.removeAccessToken(key));\n              }\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedAccessTokens)];\n\n          case 1:\n            _a.sent(); // warn if any access tokens are removed\n\n\n            if (removedAccessTokens.length > 0) {\n              this.logger.warning(removedAccessTokens.length + \" access tokens with claims in the cache keys have been removed from the cache.\");\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Add value to cookies\r\n   * @param cookieName\r\n   * @param cookieValue\r\n   * @param expires\r\n   */\n\n\n  BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\n    var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;SameSite=Lax;\";\n\n    if (expires) {\n      var expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += \"expires=\" + expireTime + \";\";\n    }\n\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n\n    document.cookie = cookieStr;\n  };\n  /**\r\n   * Get one item by key from cookies\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\n    var name = encodeURIComponent(cookieName) + \"=\";\n    var cookieList = document.cookie.split(\";\");\n\n    for (var i = 0; i < cookieList.length; i++) {\n      var cookie = cookieList[i];\n\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n\n    return Constants.EMPTY_STRING;\n  };\n  /**\r\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n   */\n\n\n  BrowserCacheManager.prototype.clearMsalCookies = function () {\n    var _this = this;\n\n    var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\n    var cookieList = document.cookie.split(\";\");\n    cookieList.forEach(function (cookie) {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        var cookieKey = cookie.split(\"=\")[0];\n\n        _this.clearItemCookie(cookieKey);\n      }\n    });\n  };\n  /**\r\n   * Clear an item in the cookies by key\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\n    this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n  };\n  /**\r\n   * Get cookie expiration time\r\n   * @param cookieLifeDays\r\n   */\n\n\n  BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\n    var today = new Date();\n    var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  };\n  /**\r\n   * Gets the cache object referenced by the browser\r\n   */\n\n\n  BrowserCacheManager.prototype.getCache = function () {\n    return this.browserStorage;\n  };\n  /**\r\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n   */\n\n\n  BrowserCacheManager.prototype.setCache = function () {// sets nothing\n  };\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n\n\n  BrowserCacheManager.prototype.generateCacheKey = function (key) {\n    var generatedKey = this.validateAndParseJson(key);\n\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n\n      return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\n    }\n\n    return JSON.stringify(key);\n  };\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\n  };\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\n  };\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n\n\n  BrowserCacheManager.prototype.generateStateKey = function (stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\n  };\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\n    var stateCacheKey = this.generateStateKey(cachedState);\n    var state = this.getTemporaryCache(stateCacheKey);\n\n    if (!state) {\n      return null;\n    }\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  };\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\"); // Cache the request state\n\n    var stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false); // Cache the nonce\n\n    var nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false); // Cache authorityKey\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n    if (account) {\n      var ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (!StringUtils.isEmpty(loginHint)) {\n      var ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  };\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.resetRequestCache = function (state) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\"); // check state and remove associated cache items\n\n    if (!StringUtils.isEmpty(state)) {\n      this.getKeys().forEach(function (key) {\n        if (key.indexOf(state) !== -1) {\n          _this.removeItem(key);\n        }\n      });\n    } // delete generic interactive request parameters\n\n\n    if (state) {\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  };\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\"); // Interaction is completed - remove interaction status.\n\n    if (stateString) {\n      var stateKey = this.generateStateKey(stateString);\n      var cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\n      this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n    }\n\n    this.clearMsalCookies();\n  };\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\"); // Loop through all keys to find state key\n\n    this.getKeys().forEach(function (key) {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      } // Retrieve state value, return if not a valid value\n\n\n      var stateValue = _this.temporaryCacheStorage.getItem(key);\n\n      if (!stateValue) {\n        return;\n      } // Extract state and ensure it matches given InteractionType, then clean request cache\n\n\n      var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\n\n      if (parsedState && parsedState.interactionType === interactionType) {\n        _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\n\n        _this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n    this.setInteractionInProgress(false);\n  };\n\n  BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  };\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\"); // Get token request from cache and parse as TokenExchangeParameters.\n\n    var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n\n    if (!encodedTokenRequest) {\n      throw BrowserAuthError.createNoTokenRequestCacheError();\n    }\n\n    var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\n\n    if (!parsedRequest) {\n      throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)); // Get cached authority and use if no authority is cached with request.\n\n    if (StringUtils.isEmpty(parsedRequest.authority)) {\n      var authorityCacheKey = this.generateAuthorityKey(state);\n      var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n\n      if (!cachedAuthority) {\n        throw BrowserAuthError.createNoCachedAuthorityError();\n      }\n\n      parsedRequest.authority = cachedAuthority;\n    }\n\n    return parsedRequest;\n  };\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedNativeRequest = function () {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    var cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n\n    var parsedRequest = this.validateAndParseJson(cachedRequest);\n\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n\n    return parsedRequest;\n  };\n\n  BrowserCacheManager.prototype.isInteractionInProgress = function (matchClientId) {\n    var clientId = this.getInteractionInProgress();\n\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  };\n\n  BrowserCacheManager.prototype.getInteractionInProgress = function () {\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n    return this.getTemporaryCache(key, false);\n  };\n\n  BrowserCacheManager.prototype.setInteractionInProgress = function (inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw BrowserAuthError.createInteractionInProgressError();\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeItem(key);\n    }\n  };\n  /**\r\n   * Returns username retrieved from ADAL or MSAL v1 idToken\r\n   */\n\n\n  BrowserCacheManager.prototype.getLegacyLoginHint = function () {\n    // Only check for adal/msal token if no SSO params are being used\n    var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n\n    if (adalIdTokenString) {\n      this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n      this.logger.verbose(\"Cached ADAL id token retrieved.\");\n    } // Check for cached MSAL v1 id token\n\n\n    var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n\n    if (msalIdTokenString) {\n      this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n      this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n    }\n\n    var cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n\n    if (cachedIdTokenString) {\n      var cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\n\n      if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n        return cachedIdToken.claims.preferred_username;\n      } else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n        return cachedIdToken.claims.upn;\n      } else {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Updates a credential's cache key if the current cache key is outdated\r\n   */\n\n\n  BrowserCacheManager.prototype.updateCredentialCacheKey = function (currentCacheKey, credential) {\n    var updatedCacheKey = credential.generateCredentialKey();\n\n    if (currentCacheKey !== updatedCacheKey) {\n      var cacheItem = this.getItem(currentCacheKey);\n\n      if (cacheItem) {\n        this.removeItem(currentCacheKey);\n        this.setItem(updatedCacheKey, cacheItem);\n        this.logger.verbose(\"Updated an outdated \" + credential.credentialType + \" cache key\");\n        return updatedCacheKey;\n      } else {\n        this.logger.error(\"Attempted to update an outdated \" + credential.credentialType + \" cache key but no item matching the outdated key was found in storage\");\n      }\n    }\n\n    return currentCacheKey;\n  };\n  /**\r\n   * Returns application id as redirect context during AcquireTokenRedirect flow.\r\n   */\n\n\n  BrowserCacheManager.prototype.getRedirectRequestContext = function () {\n    return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\n  };\n  /**\r\n   * Sets application id as the redirect context during AcquireTokenRedirect flow.\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setRedirectRequestContext = function (value) {\n    this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\n  };\n  /**\r\n   * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\r\n   * @param result\r\n   * @param request\r\n   */\n\n\n  BrowserCacheManager.prototype.hydrateCache = function (result, request) {\n    var _a, _b, _c, _d, _e, _f;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenEntity, claimsHash, accessTokenEntity, cacheRecord;\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            idTokenEntity = IdTokenEntity.createIdTokenEntity(((_a = result.account) === null || _a === void 0 ? void 0 : _a.homeAccountId) || \"\", ((_b = result.account) === null || _b === void 0 ? void 0 : _b.environment) || \"\", result.idToken, this.clientId, result.tenantId);\n            if (!request.claims) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.cryptoImpl.hashString(request.claims)];\n\n          case 1:\n            claimsHash = _g.sent();\n            _g.label = 2;\n\n          case 2:\n            accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(((_c = result.account) === null || _c === void 0 ? void 0 : _c.homeAccountId) || \"\", ((_d = result.account) === null || _d === void 0 ? void 0 : _d.environment) || \"\", result.accessToken, this.clientId, result.tenantId, result.scopes.join(\" \"), ((_e = result.expiresOn) === null || _e === void 0 ? void 0 : _e.getTime()) || 0, ((_f = result.extExpiresOn) === null || _f === void 0 ? void 0 : _f.getTime()) || 0, this.cryptoImpl, undefined, // refreshOn\n            result.tokenType, undefined, // userAssertionHash\n            request.sshKid, request.claims, claimsHash);\n            cacheRecord = new CacheRecord(undefined, idTokenEntity, accessTokenEntity);\n            return [2\n            /*return*/\n            , this.saveCacheRecord(cacheRecord)];\n        }\n      });\n    });\n  };\n\n  return BrowserCacheManager;\n}(CacheManager);\n\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\n  var cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: true\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\n\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"sources":["../../src/cache/BrowserCacheManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Constants, PersistentCacheKeys, StringUtils, CommonAuthorizationCodeRequest, ICrypto, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager, ServerTelemetryEntity, ThrottlingEntity, ProtocolUtils, Logger, AuthorityMetadataEntity, DEFAULT_CRYPTO_IMPLEMENTATION, AccountInfo, ActiveAccountFilters, CcsCredential, CcsCredentialType, IdToken, ValidCredentialType, ClientAuthError, TokenKeys, CredentialType, AuthenticationResult, AuthenticationScheme, CacheRecord } from \"@azure/msal-common\";\r\nimport { CacheOptions } from \"../config/Configuration\";\r\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\r\nimport { BrowserCacheLocation, InteractionType, TemporaryCacheKeys, InMemoryCacheKeys, StaticCacheKeys } from \"../utils/BrowserConstants\";\r\nimport { BrowserStorage } from \"./BrowserStorage\";\r\nimport { MemoryStorage } from \"./MemoryStorage\";\r\nimport { IWindowStorage } from \"./IWindowStorage\";\r\nimport { BrowserProtocolUtils } from \"../utils/BrowserProtocolUtils\";\r\nimport { NativeTokenRequest } from \"../broker/nativeBroker/NativeRequest\";\r\nimport { SilentRequest } from \"../request/SilentRequest\";\r\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\r\nimport { RedirectRequest } from \"../request/RedirectRequest\";\r\nimport { PopupRequest } from \"../request/PopupRequest\";\r\n\r\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\r\nexport class BrowserCacheManager extends CacheManager {\r\n\r\n    // Cache configuration, either set by user or default values.\r\n    protected cacheConfig: Required<CacheOptions>;\r\n    // Window storage object (either local or sessionStorage)\r\n    protected browserStorage: IWindowStorage<string>;\r\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\r\n    protected internalStorage: MemoryStorage<string>;\r\n    // Temporary cache\r\n    protected temporaryCacheStorage: IWindowStorage<string>;\r\n    // Logger instance\r\n    protected logger: Logger;\r\n\r\n    // Cookie life calculation (hours * minutes * seconds * ms)\r\n    protected readonly COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\r\n\r\n    constructor(clientId: string, cacheConfig: Required<CacheOptions>, cryptoImpl: ICrypto, logger: Logger) {\r\n        super(clientId, cryptoImpl, logger);\r\n        this.cacheConfig = cacheConfig;\r\n        this.logger = logger;\r\n        this.internalStorage = new MemoryStorage();\r\n        this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\r\n        this.temporaryCacheStorage = this.setupTemporaryCacheStorage(this.cacheConfig.temporaryCacheLocation, this.cacheConfig.cacheLocation);\r\n\r\n        // Migrate cache entries from older versions of MSAL.\r\n        if (cacheConfig.cacheMigrationEnabled) {\r\n            this.migrateCacheEntries();\r\n            this.createKeyMaps();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n     * @param cacheLocation\r\n     */\r\n    protected setupBrowserStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage<string> {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    return new BrowserStorage(cacheLocation);\r\n                } catch (e) {\r\n                    this.logger.verbose(e);\r\n                    break;\r\n                }\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                break;\r\n        }\r\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\r\n        return new MemoryStorage();\r\n    }\r\n\r\n    /**\r\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\r\n     * @param temporaryCacheLocation\r\n     * @param cacheLocation\r\n     */\r\n    protected setupTemporaryCacheStorage(temporaryCacheLocation: BrowserCacheLocation | string, cacheLocation: BrowserCacheLocation | string): IWindowStorage<string> {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    /*\r\n                     * When users do not explicitly choose their own temporaryCacheLocation, \r\n                     * temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n                     */\r\n                    return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);\r\n                } catch (e) {\r\n                    this.logger.verbose(e);\r\n                    return this.internalStorage;\r\n                }\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                return this.internalStorage;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Migrate all old cache entries to new schema. No rollback supported.\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    protected migrateCacheEntries(): void {\r\n        const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\r\n        const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\r\n        const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\r\n        const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\r\n\r\n        const idTokenValue = this.browserStorage.getItem(idTokenKey);\r\n        const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\r\n        const errorValue = this.browserStorage.getItem(errorKey);\r\n        const errorDescValue = this.browserStorage.getItem(errorDescKey);\r\n\r\n        const values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\r\n        const keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\r\n\r\n        keysToMigrate.forEach((cacheKey: string, index: number) => this.migrateCacheEntry(cacheKey, values[index]));\r\n    }\r\n\r\n    /**\r\n     * Utility function to help with migration.\r\n     * @param newKey\r\n     * @param value\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    protected migrateCacheEntry(newKey: string, value: string | null): void {\r\n        if (value) {\r\n            this.setTemporaryCache(newKey, value, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Searches all cache entries for MSAL accounts and creates the account key map\r\n     * This is used to migrate users from older versions of MSAL which did not create the map.\r\n     * @returns \r\n     */\r\n    private createKeyMaps(): void {\r\n        this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\r\n        const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\r\n        const tokenKeys = this.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\r\n        if (accountKeys && tokenKeys) {\r\n            this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\");\r\n            // Key maps already exist, no need to iterate through cache\r\n            return;\r\n        }\r\n\r\n        const allKeys = this.browserStorage.getKeys();\r\n        allKeys.forEach((key) => {\r\n            if (this.isCredentialKey(key)) {\r\n                // Get item, parse, validate and write key to map\r\n                const value = this.getItem(key);\r\n                if (value) {\r\n                    const credObj = this.validateAndParseJson(value);\r\n                    if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\r\n                        switch (credObj[\"credentialType\"]) {\r\n                            case CredentialType.ID_TOKEN:\r\n                                if (IdTokenEntity.isIdTokenEntity(credObj)) {\r\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\r\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - idToken with key: ${key} found, saving key to token key map`);\r\n                                    const idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\r\n                                    const newKey = this.updateCredentialCacheKey(key, idTokenEntity);\r\n                                    this.addTokenKey(newKey, CredentialType.ID_TOKEN);\r\n                                    return;\r\n                                } else {\r\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\r\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed idToken validation on key: ${key}`);\r\n                                }\r\n                                break;\r\n                            case CredentialType.ACCESS_TOKEN:\r\n                            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\r\n                                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\r\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\r\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - accessToken with key: ${key} found, saving key to token key map`);\r\n                                    const accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\r\n                                    const newKey = this.updateCredentialCacheKey(key, accessTokenEntity);\r\n                                    this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\r\n                                    return;\r\n                                } else {\r\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\r\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed accessToken validation on key: ${key}`);\r\n                                }\r\n                                break;\r\n                            case CredentialType.REFRESH_TOKEN:\r\n                                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\r\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\r\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - refreshToken with key: ${key} found, saving key to token key map`);\r\n                                    const refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\r\n                                    const newKey = this.updateCredentialCacheKey(key, refreshTokenEntity);\r\n                                    this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\r\n                                    return;\r\n                                } else {\r\n                                    this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\r\n                                    this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: ${key}`);\r\n                                }\r\n                                break;\r\n                            default:\r\n                                // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\r\n                        }\r\n                    }\r\n                }\r\n            } \r\n            \r\n            if (this.isAccountKey(key)) {\r\n                const value = this.getItem(key);\r\n                if (value) {\r\n                    const accountObj = this.validateAndParseJson(value);\r\n                    if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\r\n                        this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\r\n                        this.logger.tracePii(`BrowserCacheManager:createKeyMaps - account with key: ${key} found, saving key to account key map`);\r\n                        this.addAccountKeyToMap(key);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n     * @param input\r\n     */\r\n    protected validateAndParseJson(jsonValue: string): object | null {\r\n        try {\r\n            const parsedJson = JSON.parse(jsonValue);\r\n            /**\r\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n             *\r\n             */\r\n            return (parsedJson && typeof parsedJson === \"object\") ? parsedJson : null;\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * fetches the entry from the browser storage based off the key\r\n     * @param key\r\n     */\r\n    getItem(key: string): string | null {\r\n        return this.browserStorage.getItem(key);\r\n    }\r\n\r\n    /**\r\n     * sets the entry in the browser storage\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setItem(key: string, value: string): void {\r\n        this.browserStorage.setItem(key, value);\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     * @param accountKey\r\n     */\r\n    getAccount(accountKey: string): AccountEntity | null {\r\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\r\n        const account = this.getItem(accountKey);\r\n        if (!account) {\r\n            this.removeAccountKeyFromMap(accountKey);\r\n            return null;\r\n        }\r\n\r\n        const parsedAccount = this.validateAndParseJson(account);\r\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\r\n            this.removeAccountKeyFromMap(accountKey);\r\n            return null;\r\n        }\r\n\r\n        return CacheManager.toObject<AccountEntity>(new AccountEntity(), parsedAccount);\r\n    }\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setAccount(account: AccountEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\r\n        const key = account.generateAccountKey();\r\n        this.setItem(key, JSON.stringify(account));\r\n        this.addAccountKeyToMap(key);\r\n    }\r\n\r\n    /**\r\n     * Returns the array of account keys currently cached\r\n     * @returns \r\n     */\r\n    getAccountKeys(): Array<string> {\r\n        this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\r\n        const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\r\n        if (accountKeys) {\r\n            return JSON.parse(accountKeys);\r\n        }\r\n\r\n        this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Add a new account to the key map\r\n     * @param key \r\n     */\r\n    addAccountKeyToMap(key: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\r\n        this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);\r\n        const accountKeys = this.getAccountKeys();\r\n        if (accountKeys.indexOf(key) === -1) {\r\n            // Only add key if it does not already exist in the map\r\n            accountKeys.push(key);\r\n            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\r\n            this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\r\n        } else {\r\n            this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an account from the key map\r\n     * @param key \r\n     */\r\n    removeAccountKeyFromMap(key: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\r\n        this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);\r\n        const accountKeys = this.getAccountKeys();\r\n        const removalIndex = accountKeys.indexOf(key);\r\n        if (removalIndex > -1) {\r\n            accountKeys.splice(removalIndex, 1);\r\n            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\r\n            this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\r\n        } else {\r\n            this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extends inherited removeAccount function to include removal of the account key from the map\r\n     * @param key \r\n     */\r\n    async removeAccount(key: string): Promise<void> {\r\n        super.removeAccount(key);\r\n        this.removeAccountKeyFromMap(key);\r\n    }\r\n\r\n    /**\r\n     * Removes given idToken from the cache and from the key map\r\n     * @param key \r\n     */\r\n    removeIdToken(key: string): void {\r\n        super.removeIdToken(key);\r\n        this.removeTokenKey(key, CredentialType.ID_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * Removes given accessToken from the cache and from the key map\r\n     * @param key \r\n     */\r\n    async removeAccessToken(key: string): Promise<void> {\r\n        super.removeAccessToken(key);\r\n        this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * Removes given refreshToken from the cache and from the key map\r\n     * @param key \r\n     */\r\n    removeRefreshToken(key: string): void {\r\n        super.removeRefreshToken(key);\r\n        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * Gets the keys for the cached tokens associated with this clientId\r\n     * @returns \r\n     */\r\n    getTokenKeys(): TokenKeys {\r\n        this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\r\n        const item = this.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\r\n        if (item) {\r\n            const tokenKeys = this.validateAndParseJson(item);\r\n            if (tokenKeys && \r\n                tokenKeys.hasOwnProperty(\"idToken\") &&\r\n                tokenKeys.hasOwnProperty(\"accessToken\") &&\r\n                tokenKeys.hasOwnProperty(\"refreshToken\")\r\n            ) {\r\n                return tokenKeys as TokenKeys;\r\n            } else {\r\n                this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\r\n            }\r\n        } else {\r\n            this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\r\n        }\r\n\r\n        return {\r\n            idToken: [],\r\n            accessToken: [],\r\n            refreshToken: []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Adds the given key to the token key map\r\n     * @param key \r\n     * @param type \r\n     */\r\n    addTokenKey(key: string, type: CredentialType): void {\r\n        this.logger.trace(\"BrowserCacheManager addTokenKey called\");\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        switch (type) {\r\n            case CredentialType.ID_TOKEN:\r\n                if (tokenKeys.idToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\r\n                    tokenKeys.idToken.push(key);\r\n                }\r\n                break;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                if (tokenKeys.accessToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\r\n                    tokenKeys.accessToken.push(key);\r\n                }\r\n                break;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                if (tokenKeys.refreshToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\r\n                    tokenKeys.refreshToken.push(key);\r\n                }\r\n                break;\r\n            default:\r\n                this.logger.error(`BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\r\n                ClientAuthError.createUnexpectedCredentialTypeError();\r\n        }\r\n\r\n        this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\r\n    }\r\n\r\n    /**\r\n     * Removes the given key from the token key map\r\n     * @param key \r\n     * @param type \r\n     */\r\n    removeTokenKey(key: string, type: CredentialType): void {\r\n        this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        switch (type) {\r\n            case CredentialType.ID_TOKEN:\r\n                this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`);\r\n                const idRemoval = tokenKeys.idToken.indexOf(key);\r\n                if (idRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\r\n                    tokenKeys.idToken.splice(idRemoval, 1);\r\n                } else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`);\r\n                const accessRemoval = tokenKeys.accessToken.indexOf(key);\r\n                if (accessRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\r\n                    tokenKeys.accessToken.splice(accessRemoval, 1);\r\n                } else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`);\r\n                const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\r\n                if (refreshRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\r\n                    tokenKeys.refreshToken.splice(refreshRemoval, 1);\r\n                } else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            default:\r\n                this.logger.error(`BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\r\n                ClientAuthError.createUnexpectedCredentialTypeError();\r\n        }\r\n\r\n        this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\r\n    }\r\n\r\n    /**\r\n     * generates idToken entity from a string\r\n     * @param idTokenKey\r\n     */\r\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\r\n        const value = this.getItem(idTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n            return null;\r\n        }\r\n\r\n        const parsedIdToken = this.validateAndParseJson(value);\r\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\r\n    }\r\n\r\n    /**\r\n     * set IdToken credential to the platform cache\r\n     * @param idToken\r\n     */\r\n    setIdTokenCredential(idToken: IdTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\r\n        const idTokenKey = idToken.generateCredentialKey();\r\n\r\n        this.setItem(idTokenKey, JSON.stringify(idToken));\r\n\r\n        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * generates accessToken entity from a string\r\n     * @param key\r\n     */\r\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\r\n        const value = this.getItem(accessTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n            return null;\r\n        }\r\n        const parsedAccessToken = this.validateAndParseJson(value);\r\n        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\r\n    }\r\n\r\n    /**\r\n     * set accessToken credential to the platform cache\r\n     * @param accessToken\r\n     */\r\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\r\n        const accessTokenKey = accessToken.generateCredentialKey();\r\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\r\n\r\n        this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * generates refreshToken entity from a string\r\n     * @param refreshTokenKey\r\n     */\r\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\r\n        const value = this.getItem(refreshTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n            return null;\r\n        }\r\n        const parsedRefreshToken = this.validateAndParseJson(value);\r\n        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\r\n    }\r\n\r\n    /**\r\n     * set refreshToken credential to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\r\n        const refreshTokenKey = refreshToken.generateCredentialKey();\r\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\r\n\r\n        this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\r\n        const value = this.getItem(appMetadataKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\r\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\r\n    }\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\r\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\r\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\r\n    }\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null {\r\n        const value = this.getItem(serverTelemetryKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\r\n        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\r\n    }\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\r\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\r\n        const value = this.internalStorage.getItem(key);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\r\n            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        const allKeys = this.internalStorage.getKeys();\r\n        return allKeys.filter((key) => {\r\n            return this.isAuthorityMetadata(key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets wrapper metadata in memory\r\n     * @param wrapperSKU\r\n     * @param wrapperVersion\r\n     */\r\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\r\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\r\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\r\n    }\r\n\r\n    /**\r\n     * Returns wrapper metadata from in-memory storage\r\n     */\r\n    getWrapperMetadata(): [string, string] {\r\n        const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\r\n        const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\r\n        return [sku, version];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param entity\r\n     */\r\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\r\n        this.internalStorage.setItem(key, JSON.stringify(entity));\r\n    }\r\n\r\n    /**\r\n     * Gets the active account\r\n     */\r\n    getActiveAccount(): AccountInfo | null {\r\n        const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\r\n        const activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\r\n        if (!activeAccountValueFilters) {\r\n            // if new active account cache type isn't found, it's an old version, so look for that instead\r\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\r\n            const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n            const activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\r\n            if (!activeAccountValueLocal) {\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\r\n                return null;\r\n            }\r\n            const activeAccount = this.getAccountInfoByFilter({ localAccountId: activeAccountValueLocal })[0] || null;\r\n            if (activeAccount) {\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\r\n                this.setActiveAccount(activeAccount);\r\n                return activeAccount;\r\n            }\r\n            return null;\r\n        }\r\n        const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters) as AccountInfo;\r\n        if (activeAccountValueObj) {\r\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\r\n            return this.getAccountInfoByFilter({\r\n                homeAccountId: activeAccountValueObj.homeAccountId,\r\n                localAccountId: activeAccountValueObj.localAccountId\r\n            })[0] || null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the active account's localAccountId in cache\r\n     * @param account\r\n     */\r\n    setActiveAccount(account: AccountInfo | null): void {\r\n        const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\r\n        const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n        if (account) {\r\n            this.logger.verbose(\"setActiveAccount: Active account set\");\r\n            const activeAccountValue: ActiveAccountFilters = {\r\n                homeAccountId: account.homeAccountId,\r\n                localAccountId: account.localAccountId\r\n            };\r\n            this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\r\n            this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\r\n        } else {\r\n            this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\r\n            this.browserStorage.removeItem(activeAccountKey);\r\n            this.browserStorage.removeItem(activeAccountKeyLocal);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of accounts that match all of the filters provided\r\n     * @param account\r\n     */\r\n    getAccountInfoByFilter(accountFilter: Partial<Omit<AccountInfo, \"idTokenClaims\" | \"name\">>): AccountInfo[] {\r\n        const allAccounts = this.getAllAccounts();\r\n        this.logger.trace(`BrowserCacheManager.getAccountInfoByFilter: total ${allAccounts.length} accounts found`);\r\n\r\n        return allAccounts.filter((accountObj) => {\r\n            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks the cache for accounts matching loginHint or SID\r\n     * @param loginHint\r\n     * @param sid\r\n     */\r\n    getAccountInfoByHints(loginHint?: string, sid?: string): AccountInfo | null {\r\n        const matchingAccounts = this.getAllAccounts().filter((accountInfo) => {\r\n            if (sid) {\r\n                const accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\r\n                return sid === accountSid;\r\n            }\r\n\r\n            if (loginHint) {\r\n                return loginHint === accountInfo.username;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        if (matchingAccounts.length === 1) {\r\n            return matchingAccounts[0];\r\n        } else if (matchingAccounts.length > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\r\n        const value = this.getItem(throttlingCacheKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        const parsedThrottlingCache = this.validateAndParseJson(value);\r\n        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\r\n        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\r\n    }\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\r\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key.\r\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\r\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            const itemCookie = this.getItemCookie(key);\r\n            if (itemCookie) {\r\n                this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\r\n                return itemCookie;\r\n            }\r\n        }\r\n\r\n        const value = this.temporaryCacheStorage.getItem(key);\r\n        if (!value) {\r\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\r\n            if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\r\n                const item = this.browserStorage.getItem(key);\r\n                if (item) {\r\n                    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\r\n                    return item;\r\n                }\r\n            }\r\n            this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Sets the cache item with the key and value given.\r\n     * Stores in cookie if storeAuthStateInCookie is set to true.\r\n     * This can cause cookie overflow if used incorrectly.\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setTemporaryCache(cacheKey: string, value: string, generateKey?: boolean): void {\r\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n\r\n        this.temporaryCacheStorage.setItem(key, value);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\r\n            this.setItemCookie(key, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the cache item with the given key.\r\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    removeItem(key: string): void {\r\n        this.browserStorage.removeItem(key);\r\n        this.temporaryCacheStorage.removeItem(key);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\r\n            this.clearItemCookie(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key\r\n     */\r\n    containsKey(key: string): boolean {\r\n        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\r\n    }\r\n\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys(): string[] {\r\n        return [\r\n            ...this.browserStorage.getKeys(),\r\n            ...this.temporaryCacheStorage.getKeys()\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Clears all cache entries created by MSAL.\r\n     */\r\n    async clear(): Promise<void> {\r\n        // Removes all accounts and their credentials\r\n        await this.removeAllAccounts();\r\n        this.removeAppMetadata();\r\n\r\n        // Removes all remaining MSAL cache items\r\n        this.getKeys().forEach((cacheKey: string) => {\r\n            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\r\n            if ((this.browserStorage.containsKey(cacheKey) || this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(this.clientId) !== -1))) {\r\n                this.removeItem(cacheKey);\r\n            }\r\n        });\r\n\r\n        this.internalStorage.clear();\r\n    }\r\n\r\n    /**\r\n     * Clears all access tokes that have claims prior to saving the current one\r\n     * @param credential \r\n     * @returns \r\n     */\r\n    async clearTokensAndKeysWithClaims(): Promise<void> {\r\n\r\n        this.logger.trace(\"BrowserCacheManager.clearTokensAndKeysWithClaims called\");\r\n        const tokenKeys = this.getTokenKeys();\r\n            \r\n        const removedAccessTokens: Array<Promise<void>> = [];\r\n        tokenKeys.accessToken.forEach((key: string) => {\r\n            // if the access token has claims in its key, remove the token key and the token\r\n            const credential = this.getAccessTokenCredential(key);\r\n            if(credential?.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {\r\n                removedAccessTokens.push(this.removeAccessToken(key));\r\n            }\r\n        });\r\n        await Promise.all(removedAccessTokens);\r\n\r\n        // warn if any access tokens are removed\r\n        if(removedAccessTokens.length > 0) {\r\n            this.logger.warning(`${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add value to cookies\r\n     * @param cookieName\r\n     * @param cookieValue\r\n     * @param expires\r\n     */\r\n    setItemCookie(cookieName: string, cookieValue: string, expires?: number): void {\r\n        let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(cookieValue)};path=/;SameSite=Lax;`;\r\n        if (expires) {\r\n            const expireTime = this.getCookieExpirationTime(expires);\r\n            cookieStr += `expires=${expireTime};`;\r\n        }\r\n\r\n        if (this.cacheConfig.secureCookies) {\r\n            cookieStr += \"Secure;\";\r\n        }\r\n\r\n        document.cookie = cookieStr;\r\n    }\r\n\r\n    /**\r\n     * Get one item by key from cookies\r\n     * @param cookieName\r\n     */\r\n    getItemCookie(cookieName: string): string {\r\n        const name = `${encodeURIComponent(cookieName)}=`;\r\n        const cookieList = document.cookie.split(\";\");\r\n        for (let i: number = 0; i < cookieList.length; i++) {\r\n            let cookie = cookieList[i];\r\n            while (cookie.charAt(0) === \" \") {\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(name) === 0) {\r\n                return decodeURIComponent(cookie.substring(name.length, cookie.length));\r\n            }\r\n        }\r\n        return Constants.EMPTY_STRING;\r\n    }\r\n\r\n    /**\r\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n     */\r\n    clearMsalCookies(): void {\r\n        const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\r\n        const cookieList = document.cookie.split(\";\");\r\n        cookieList.forEach((cookie: string): void => {\r\n            while (cookie.charAt(0) === \" \") {\r\n                // eslint-disable-next-line no-param-reassign\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(cookiePrefix) === 0) {\r\n                const cookieKey = cookie.split(\"=\")[0];\r\n                this.clearItemCookie(cookieKey);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear an item in the cookies by key\r\n     * @param cookieName\r\n     */\r\n    clearItemCookie(cookieName: string): void {\r\n        this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\r\n    }\r\n\r\n    /**\r\n     * Get cookie expiration time\r\n     * @param cookieLifeDays\r\n     */\r\n    getCookieExpirationTime(cookieLifeDays: number): string {\r\n        const today = new Date();\r\n        const expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\r\n        return expr.toUTCString();\r\n    }\r\n\r\n    /**\r\n     * Gets the cache object referenced by the browser\r\n     */\r\n    getCache(): object {\r\n        return this.browserStorage;\r\n    }\r\n\r\n    /**\r\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n     */\r\n    setCache(): void {\r\n        // sets nothing\r\n    }\r\n\r\n    /**\r\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n     * @param key\r\n     * @param addInstanceId\r\n     */\r\n    generateCacheKey(key: string): string {\r\n        const generatedKey = this.validateAndParseJson(key);\r\n        if (!generatedKey) {\r\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\r\n                return key;\r\n            }\r\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\r\n        }\r\n\r\n        return JSON.stringify(key);\r\n    }\r\n\r\n    /**\r\n     * Create authorityKey to cache authority\r\n     * @param state\r\n     */\r\n    generateAuthorityKey(stateString: string): string {\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\r\n    }\r\n\r\n    /**\r\n     * Create Nonce key to cache nonce\r\n     * @param state\r\n     */\r\n    generateNonceKey(stateString: string): string {\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\r\n    }\r\n\r\n    /**\r\n     * Creates full cache key for the request state\r\n     * @param stateString State string for the request\r\n     */\r\n    generateStateKey(stateString: string): string {\r\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\r\n    }\r\n\r\n    /**\r\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n     */\r\n    getCachedAuthority(cachedState: string): string | null {\r\n        const stateCacheKey = this.generateStateKey(cachedState);\r\n        const state = this.getTemporaryCache(stateCacheKey);\r\n        if (!state) {\r\n            return null;\r\n        }\r\n\r\n        const authorityCacheKey = this.generateAuthorityKey(state);\r\n        return this.getTemporaryCache(authorityCacheKey);\r\n    }\r\n\r\n    /**\r\n     * Updates account, authority, and state in cache\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     */\r\n    updateCacheEntries(state: string, nonce: string, authorityInstance: string, loginHint: string, account: AccountInfo | null): void {\r\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\r\n        // Cache the request state\r\n        const stateCacheKey = this.generateStateKey(state);\r\n        this.setTemporaryCache(stateCacheKey, state, false);\r\n\r\n        // Cache the nonce\r\n        const nonceCacheKey = this.generateNonceKey(state);\r\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\r\n\r\n        // Cache authorityKey\r\n        const authorityCacheKey = this.generateAuthorityKey(state);\r\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\r\n\r\n        if (account) {\r\n            const ccsCredential: CcsCredential = {\r\n                credential: account.homeAccountId,\r\n                type: CcsCredentialType.HOME_ACCOUNT_ID\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        } else if (!StringUtils.isEmpty(loginHint)) {\r\n            const ccsCredential: CcsCredential = {\r\n                credential: loginHint,\r\n                type: CcsCredentialType.UPN\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset all temporary cache items\r\n     * @param state\r\n     */\r\n    resetRequestCache(state: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\r\n        // check state and remove associated cache items\r\n        if (!StringUtils.isEmpty(state)) {\r\n            this.getKeys().forEach(key => {\r\n                if (key.indexOf(state) !== -1) {\r\n                    this.removeItem(key);\r\n                }\r\n            });\r\n        }\r\n\r\n        // delete generic interactive request parameters\r\n        if (state) {\r\n            this.removeItem(this.generateStateKey(state));\r\n            this.removeItem(this.generateNonceKey(state));\r\n            this.removeItem(this.generateAuthorityKey(state));\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\r\n        this.setInteractionInProgress(false);\r\n    }\r\n\r\n    /**\r\n     * Removes temporary cache for the provided state\r\n     * @param stateString\r\n     */\r\n    cleanRequestByState(stateString: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\r\n        // Interaction is completed - remove interaction status.\r\n        if (stateString) {\r\n            const stateKey = this.generateStateKey(stateString);\r\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\r\n            this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\r\n            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\r\n        }\r\n        this.clearMsalCookies();\r\n    }\r\n\r\n    /**\r\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n     * @param interactionType\r\n     */\r\n    cleanRequestByInteractionType(interactionType: InteractionType): void {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\r\n        // Loop through all keys to find state key\r\n        this.getKeys().forEach((key) => {\r\n            // If this key is not the state key, move on\r\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\r\n                return;\r\n            }\r\n\r\n            // Retrieve state value, return if not a valid value\r\n            const stateValue = this.temporaryCacheStorage.getItem(key);\r\n            if (!stateValue) {\r\n                return;\r\n            }\r\n            // Extract state and ensure it matches given InteractionType, then clean request cache\r\n            const parsedState = BrowserProtocolUtils.extractBrowserRequestState(this.cryptoImpl, stateValue);\r\n            if (parsedState && parsedState.interactionType === interactionType) {\r\n                this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\r\n                this.resetRequestCache(stateValue);\r\n            }\r\n        });\r\n        this.clearMsalCookies();\r\n        this.setInteractionInProgress(false);\r\n    }\r\n\r\n    cacheCodeRequest(authCodeRequest: CommonAuthorizationCodeRequest, browserCrypto: ICrypto): void {\r\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\r\n\r\n        const encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\r\n        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n     */\r\n    getCachedRequest(state: string, browserCrypto: ICrypto): CommonAuthorizationCodeRequest {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\r\n        // Get token request from cache and parse as TokenExchangeParameters.\r\n        const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\r\n        if (!encodedTokenRequest) {\r\n            throw BrowserAuthError.createNoTokenRequestCacheError();\r\n        }\r\n\r\n        const parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest)) as CommonAuthorizationCodeRequest;\r\n        if (!parsedRequest) {\r\n            throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n\r\n        // Get cached authority and use if no authority is cached with request.\r\n        if (StringUtils.isEmpty(parsedRequest.authority)) {\r\n            const authorityCacheKey: string = this.generateAuthorityKey(state);\r\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\r\n            if (!cachedAuthority) {\r\n                throw BrowserAuthError.createNoCachedAuthorityError();\r\n            }\r\n            parsedRequest.authority = cachedAuthority;\r\n        }\r\n\r\n        return parsedRequest;\r\n    }\r\n\r\n    /**\r\n     * Gets cached native request for redirect flows\r\n     */\r\n    getCachedNativeRequest(): NativeTokenRequest | null {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\r\n        const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\r\n        if (!cachedRequest) {\r\n            this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\r\n            return null;\r\n        }\r\n\r\n        const parsedRequest = this.validateAndParseJson(cachedRequest) as NativeTokenRequest;\r\n        if (!parsedRequest) {\r\n            this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\r\n            return null;\r\n        }\r\n\r\n        return parsedRequest;\r\n    }\r\n\r\n    isInteractionInProgress(matchClientId?: boolean): boolean {\r\n        const clientId = this.getInteractionInProgress();\r\n\r\n        if (matchClientId) {\r\n            return clientId === this.clientId;\r\n        } else {\r\n            return !!clientId;\r\n        }\r\n    }\r\n\r\n    getInteractionInProgress(): string | null {\r\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\r\n        return this.getTemporaryCache(key, false);\r\n    }\r\n\r\n    setInteractionInProgress(inProgress: boolean): void {\r\n        // Ensure we don't overwrite interaction in progress for a different clientId\r\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\r\n        if (inProgress) {\r\n            if (this.getInteractionInProgress()) {\r\n                throw BrowserAuthError.createInteractionInProgressError();\r\n            } else {\r\n                // No interaction is in progress\r\n                this.setTemporaryCache(key, this.clientId, false);\r\n            }\r\n        } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\r\n            this.removeItem(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns username retrieved from ADAL or MSAL v1 idToken\r\n     */\r\n    getLegacyLoginHint(): string | null {\r\n        // Only check for adal/msal token if no SSO params are being used\r\n        const adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\r\n        if (adalIdTokenString) {\r\n            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\r\n            this.logger.verbose(\"Cached ADAL id token retrieved.\");\r\n        }\r\n\r\n        // Check for cached MSAL v1 id token\r\n        const msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\r\n        if (msalIdTokenString) {\r\n            this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\r\n            this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\r\n        }\r\n\r\n        const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\r\n        if (cachedIdTokenString) {\r\n            const cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\r\n            if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\r\n                return cachedIdToken.claims.preferred_username;\r\n            }\r\n            else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\r\n                return cachedIdToken.claims.upn;\r\n            }\r\n            else {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Updates a credential's cache key if the current cache key is outdated\r\n     */\r\n    updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string {\r\n        const updatedCacheKey = credential.generateCredentialKey();\r\n\r\n        if (currentCacheKey !== updatedCacheKey) {\r\n            const cacheItem = this.getItem(currentCacheKey);\r\n            if (cacheItem) {\r\n                this.removeItem(currentCacheKey);\r\n                this.setItem(updatedCacheKey, cacheItem);\r\n                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\r\n                return updatedCacheKey;\r\n            } else {\r\n                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\r\n            }\r\n        }\r\n\r\n        return currentCacheKey;\r\n    }\r\n\r\n    /**\r\n     * Returns application id as redirect context during AcquireTokenRedirect flow.\r\n     */\r\n    getRedirectRequestContext(): string | null {\r\n        return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\r\n    }\r\n\r\n    /**\r\n     * Sets application id as the redirect context during AcquireTokenRedirect flow.\r\n     * @param value\r\n     */\r\n    setRedirectRequestContext(value: string): void {\r\n        this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\r\n    }\r\n\r\n    /**\r\n     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\r\n     * @param result\r\n     * @param request\r\n     */\r\n    async hydrateCache(\r\n        result: AuthenticationResult,\r\n        request: SilentRequest\r\n        | SsoSilentRequest\r\n        | RedirectRequest\r\n        | PopupRequest\r\n    ): Promise<void> {\r\n        const idTokenEntity = IdTokenEntity.createIdTokenEntity(\r\n            result.account?.homeAccountId || \"\" ,\r\n            result.account?.environment || \"\",\r\n            result.idToken,\r\n            this.clientId,\r\n            result.tenantId\r\n        );\r\n\r\n        let claimsHash;\r\n        if (request.claims) {\r\n            claimsHash = await this.cryptoImpl.hashString(request.claims);\r\n        }\r\n        const accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(\r\n            result.account?.homeAccountId || \"\",\r\n            result.account?.environment || \"\",\r\n            result.accessToken,\r\n            this.clientId,\r\n            result.tenantId,\r\n            result.scopes.join(\" \"),\r\n            result.expiresOn?.getTime() || 0,\r\n            result.extExpiresOn?.getTime() || 0,\r\n            this.cryptoImpl,\r\n            undefined, // refreshOn\r\n            result.tokenType as AuthenticationScheme,\r\n            undefined, // userAssertionHash\r\n            request.sshKid,\r\n            request.claims,\r\n            claimsHash\r\n        );\r\n\r\n        const cacheRecord = new CacheRecord(\r\n            undefined,\r\n            idTokenEntity,\r\n            accessTokenEntity\r\n        );\r\n        return this.saveCacheRecord(cacheRecord);\r\n    }\r\n}\r\n\r\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (clientId: string, logger: Logger): BrowserCacheManager => {\r\n    const cacheOptions: Required<CacheOptions> = {\r\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        storeAuthStateInCookie: false,\r\n        secureCookies: false,\r\n        cacheMigrationEnabled: false,\r\n        claimsBasedCachingEnabled: true\r\n    };\r\n    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}