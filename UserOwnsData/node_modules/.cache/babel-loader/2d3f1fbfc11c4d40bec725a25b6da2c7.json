{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { IntFields, PerformanceEventStatus } from './PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar PerformanceClient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   */\n  function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.queueMeasurements = new Map();\n    this.preQueueTimeByCorrelationId = new Map();\n  }\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this function can be changed to abstract at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n\n\n  PerformanceClient.prototype.startPerformanceMeasurement = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this incorrectly-named function will be removed at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n\n\n  PerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Get integral fields.\r\n   * Override to change the set.\r\n   */\n\n\n  PerformanceClient.prototype.getIntFields = function () {\n    return IntFields;\n  };\n  /**\r\n   * Gets map of pre-queue times by correlation Id\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {string} correlationId\r\n   * @returns {number}\r\n   */\n\n\n  PerformanceClient.prototype.getPreQueueTime = function (eventName, correlationId) {\n    var preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n\n    if (!preQueueEvent) {\n      this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: \" + correlationId + \", unable to add queue measurement\");\n      return;\n    } else if (preQueueEvent.name !== eventName) {\n      this.logger.trace(\"PerformanceClient.getPreQueueTime: no pre-queue time found for \" + eventName + \", unable to add queue measurement\");\n      return;\n    }\n\n    return preQueueEvent.time;\n  };\n  /**\r\n   * Calculates the difference between current time and time when function was queued.\r\n   * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\r\n   *\r\n   * @param {number} preQueueTime\r\n   * @param {number} currentTime\r\n   * @returns {number}\r\n   */\n\n\n  PerformanceClient.prototype.calculateQueuedTime = function (preQueueTime, currentTime) {\n    if (preQueueTime < 1) {\n      this.logger.trace(\"PerformanceClient: preQueueTime should be a positive integer and not \" + preQueueTime);\n      return 0;\n    }\n\n    if (currentTime < 1) {\n      this.logger.trace(\"PerformanceClient: currentTime should be a positive integer and not \" + currentTime);\n      return 0;\n    }\n\n    if (currentTime < preQueueTime) {\n      this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n      return 0;\n    }\n\n    return currentTime - preQueueTime;\n  };\n  /**\r\n   * Adds queue measurement time to QueueMeasurements array for given correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {?string} correlationId\r\n   * @param {?number} queueTime\r\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n   * @returns\r\n   */\n\n\n  PerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!correlationId) {\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: correlationId not provided for \" + eventName + \", cannot add queue measurement\");\n      return;\n    }\n\n    if (queueTime === 0) {\n      // Possible for there to be no queue time after calculation\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: queue time provided for \" + eventName + \" is \" + queueTime);\n    } else if (!queueTime) {\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: no queue time provided for \" + eventName);\n      return;\n    }\n\n    var queueMeasurement = {\n      eventName: eventName,\n      queueTime: queueTime,\n      manuallyCompleted: manuallyCompleted\n    }; // Adds to existing correlation Id if present in queueMeasurements\n\n    var existingMeasurements = this.queueMeasurements.get(correlationId);\n\n    if (existingMeasurements) {\n      existingMeasurements.push(queueMeasurement);\n      this.queueMeasurements.set(correlationId, existingMeasurements);\n    } else {\n      // Sets new correlation Id if not present in queueMeasurements\n      this.logger.trace(\"PerformanceClient.addQueueMeasurement: adding correlationId \" + correlationId + \" to queue measurements\");\n      var measurementArray = [queueMeasurement];\n      this.queueMeasurements.set(correlationId, measurementArray);\n    } // Delete processed pre-queue event.\n\n\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n\n\n  PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this;\n\n    var _a, _b; // Generate a placeholder correlation if the request does not provide one\n\n\n    var eventCorrelationId = correlationId || this.generateId();\n\n    if (!correlationId) {\n      this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\n    } // Duplicate code to address spelling error will be removed at the next major version bump.\n\n\n    this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\n    var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n    performanceMeasurement.startMeasurement();\n    var inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId,\n      appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\n      appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion\n    }; // Store in progress events so they can be discarded if not ended properly\n\n    this.cacheEventByCorrelationId(inProgressEvent); // Return the event and functions the caller can use to properly end/flush the measurement\n\n    return {\n      endMeasurement: function (event) {\n        return _this.endMeasurement(__assign(__assign({}, inProgressEvent), event), performanceMeasurement);\n      },\n      discardMeasurement: function () {\n        return _this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      addStaticFields: function (fields) {\n        return _this.addStaticFields(fields, inProgressEvent.correlationId);\n      },\n      increment: function (counters) {\n        return _this.increment(counters, inProgressEvent.correlationId);\n      },\n      measurement: performanceMeasurement,\n      event: inProgressEvent\n    };\n  };\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\r\n   * otherwise.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @param {IPerformanceMeasurement} measurement\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n\n\n  PerformanceClient.prototype.endMeasurement = function (event, measurement) {\n    var _this = this;\n\n    var _a, _b;\n\n    var rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n\n    if (!rootEvent) {\n      this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\n      return null;\n    }\n\n    var isRoot = event.eventId === rootEvent.eventId;\n    var queueInfo = {\n      totalQueueTime: 0,\n      totalQueueCount: 0,\n      manuallyCompletedCount: 0\n    };\n\n    if (isRoot) {\n      queueInfo = this.getQueueInfo(event.correlationId);\n      this.discardCache(rootEvent.correlationId);\n    } else {\n      (_a = rootEvent.incompleteSubMeasurements) === null || _a === void 0 ? void 0 : _a.delete(event.eventId);\n    }\n\n    measurement === null || measurement === void 0 ? void 0 : measurement.endMeasurement();\n    var durationMs = measurement === null || measurement === void 0 ? void 0 : measurement.flushMeasurement(); // null indicates no measurement was taken (e.g. needed performance APIs not present)\n\n    if (!durationMs) {\n      this.logger.trace(\"PerformanceClient: Performance measurement not taken\", rootEvent.correlationId);\n      return null;\n    }\n\n    this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId); // Add sub-measurement attribute to root event.\n\n    if (!isRoot) {\n      rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\n      return __assign({}, rootEvent);\n    }\n\n    var finalEvent = __assign(__assign({}, rootEvent), event);\n\n    var incompleteSubsCount = 0; // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\n\n    (_b = finalEvent.incompleteSubMeasurements) === null || _b === void 0 ? void 0 : _b.forEach(function (subMeasurement) {\n      _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + subMeasurement.name + \" found for \" + event.name, finalEvent.correlationId);\n\n      incompleteSubsCount++;\n    });\n    finalEvent.incompleteSubMeasurements = undefined;\n    finalEvent = __assign(__assign({}, finalEvent), {\n      durationMs: Math.round(durationMs),\n      queuedTimeMs: queueInfo.totalQueueTime,\n      queuedCount: queueInfo.totalQueueCount,\n      queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\n      status: PerformanceEventStatus.Completed,\n      incompleteSubsCount: incompleteSubsCount\n    });\n    this.truncateIntegralFields(finalEvent, this.getIntFields());\n    this.emitEvents([finalEvent], event.correlationId);\n    return finalEvent;\n  };\n  /**\r\n   * Saves extra information to be emitted when the measurements are flushed\r\n   * @param fields\r\n   * @param correlationId\r\n   */\n\n\n  PerformanceClient.prototype.addStaticFields = function (fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating static fields\");\n    var event = this.eventsByCorrelationId.get(correlationId);\n\n    if (event) {\n      this.eventsByCorrelationId.set(correlationId, __assign(__assign({}, event), fields));\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  };\n  /**\r\n   * Increment counters to be emitted when the measurements are flushed\r\n   * @param counters {Counters}\r\n   * @param correlationId {string} correlation identifier\r\n   */\n\n\n  PerformanceClient.prototype.increment = function (counters, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating counters\");\n    var event = this.eventsByCorrelationId.get(correlationId);\n\n    if (event) {\n      for (var counter in counters) {\n        if (!event.hasOwnProperty(counter)) {\n          event[counter] = 0;\n        }\n\n        event[counter] += counters[counter];\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  };\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n\n\n  PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\n    var rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n\n    if (rootEvent) {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\n      rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\n      rootEvent.incompleteSubMeasurements.set(event.eventId, {\n        name: event.name,\n        startTimeMs: event.startTimeMs\n      });\n    } else {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, __assign({}, event));\n    }\n  };\n\n  PerformanceClient.prototype.getQueueInfo = function (correlationId) {\n    var queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n\n    if (!queueMeasurementForCorrelationId) {\n      this.logger.trace(\"PerformanceClient: no queue measurements found for for correlationId: \" + correlationId);\n    }\n\n    var totalQueueTime = 0;\n    var totalQueueCount = 0;\n    var manuallyCompletedCount = 0;\n    queueMeasurementForCorrelationId === null || queueMeasurementForCorrelationId === void 0 ? void 0 : queueMeasurementForCorrelationId.forEach(function (measurement) {\n      totalQueueTime += measurement.queueTime;\n      totalQueueCount++;\n      manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\n    });\n    return {\n      totalQueueTime: totalQueueTime,\n      totalQueueCount: totalQueueCount,\n      manuallyCompletedCount: manuallyCompletedCount\n    };\n  };\n  /**\r\n   * Removes measurements for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n\n\n  PerformanceClient.prototype.discardMeasurements = function (correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Removes cache for a given correlation id.\r\n   *\r\n   * @param {string} correlationId correlation identifier\r\n   */\n\n\n  PerformanceClient.prototype.discardCache = function (correlationId) {\n    this.discardMeasurements(correlationId);\n    this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n    this.queueMeasurements.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n\n\n  PerformanceClient.prototype.addPerformanceCallback = function (callback) {\n    var callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\n    return callbackId;\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n\n\n  PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\n    var result = this.callbacks.delete(callbackId);\n\n    if (result) {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\n    } else {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\n    }\n\n    return result;\n  };\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n\n\n  PerformanceClient.prototype.emitEvents = function (events, correlationId) {\n    var _this = this;\n\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach(function (callback, callbackId) {\n      _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\n\n      callback.apply(null, [events]);\n    });\n  };\n  /**\r\n   * Enforce truncation of integral fields in performance event.\r\n   * @param {PerformanceEvent} event performance event to update.\r\n   * @param {Set<string>} intFields integral fields.\r\n   */\n\n\n  PerformanceClient.prototype.truncateIntegralFields = function (event, intFields) {\n    intFields.forEach(function (key) {\n      if (key in event && typeof event[key] === \"number\") {\n        event[key] = Math.floor(event[key]);\n      }\n    });\n  };\n\n  return PerformanceClient;\n}();\n\nexport { PerformanceClient };","map":{"version":3,"sources":["../../../src/telemetry/performance/PerformanceClient.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ApplicationTelemetry } from \"../../config/ClientConfiguration\";\r\nimport { Logger } from \"../../logger/Logger\";\r\nimport {\r\n    InProgressPerformanceEvent,\r\n    IPerformanceClient,\r\n    PerformanceCallbackFunction,\r\n    QueueMeasurement\r\n} from \"./IPerformanceClient\";\r\nimport { IPerformanceMeasurement } from \"./IPerformanceMeasurement\";\r\nimport {\r\n    Counters,\r\n    IntFields,\r\n    PerformanceEvent,\r\n    PerformanceEvents,\r\n    PerformanceEventStatus,\r\n    StaticFields\r\n} from \"./PerformanceEvent\";\r\n\r\nexport interface PreQueueEvent {\r\n    name: PerformanceEvents;\r\n    time: number;\r\n}\r\n\r\nexport abstract class PerformanceClient implements IPerformanceClient {\r\n    protected authority: string;\r\n    protected libraryName: string;\r\n    protected libraryVersion: string;\r\n    protected applicationTelemetry: ApplicationTelemetry;\r\n    protected clientId: string;\r\n    protected logger: Logger;\r\n    protected callbacks: Map<string, PerformanceCallbackFunction>;\r\n\r\n    /**\r\n     * Multiple events with the same correlation id.\r\n     * @protected\r\n     * @type {Map<string, PerformanceEvent>}\r\n     */\r\n    protected eventsByCorrelationId: Map<string, PerformanceEvent>;\r\n\r\n    /**\r\n     * Map of pre-queue times by correlation Id\r\n     *\r\n     * @protected\r\n     * @type {Map<string, PreQueueEvent>}\r\n     */\r\n    protected preQueueTimeByCorrelationId: Map<string, PreQueueEvent>;\r\n\r\n    /**\r\n     * Map of queue measurements by correlation Id\r\n     *\r\n     * @protected\r\n     * @type {Map<string, Array<QueueMeasurement>>}\r\n     */\r\n    protected queueMeasurements: Map<string, Array<QueueMeasurement>>;\r\n\r\n    /**\r\n     * Creates an instance of PerformanceClient,\r\n     * an abstract class containing core performance telemetry logic.\r\n     *\r\n     * @constructor\r\n     * @param {string} clientId Client ID of the application\r\n     * @param {string} authority Authority used by the application\r\n     * @param {Logger} logger Logger used by the application\r\n     * @param {string} libraryName Name of the library\r\n     * @param {string} libraryVersion Version of the library\r\n     */\r\n    constructor(clientId: string, authority: string, logger: Logger, libraryName: string, libraryVersion: string, applicationTelemetry: ApplicationTelemetry) {\r\n        this.authority = authority;\r\n        this.libraryName = libraryName;\r\n        this.libraryVersion = libraryVersion;\r\n        this.applicationTelemetry = applicationTelemetry;\r\n        this.clientId = clientId;\r\n        this.logger = logger;\r\n        this.callbacks = new Map();\r\n        this.eventsByCorrelationId = new Map();\r\n        this.queueMeasurements = new Map();\r\n        this.preQueueTimeByCorrelationId = new Map();\r\n    }\r\n\r\n    /**\r\n     * Generates and returns a unique id, typically a guid.\r\n     *\r\n     * @abstract\r\n     * @returns {string}\r\n     */\r\n    abstract generateId(): string;\r\n\r\n    /**\r\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n     * Note: this function can be changed to abstract at the next major version bump.\r\n     *\r\n     * @param {string} measureName\r\n     * @param {string} correlationId\r\n     * @returns {IPerformanceMeasurement}\r\n     */\r\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\n    startPerformanceMeasurement(measureName: string, correlationId: string): IPerformanceMeasurement {\r\n        return {} as IPerformanceMeasurement;\r\n    }\r\n\r\n    /**\r\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n     * Note: this incorrectly-named function will be removed at the next major version bump.\r\n     *\r\n     * @param {string} measureName\r\n     * @param {string} correlationId\r\n     * @returns {IPerformanceMeasurement}\r\n     */\r\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\n    startPerformanceMeasuremeant(measureName: string, correlationId: string): IPerformanceMeasurement {\r\n        return {} as IPerformanceMeasurement;\r\n    }\r\n\r\n    /**\r\n     * Sets pre-queue time by correlation Id\r\n     *\r\n     * @abstract\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {string} correlationId\r\n     * @returns\r\n     */\r\n    abstract setPreQueueTime(eventName: PerformanceEvents, correlationId?: string): void;\r\n\r\n    /**\r\n     * Get integral fields.\r\n     * Override to change the set.\r\n     */\r\n    getIntFields(): ReadonlySet<string> {\r\n        return IntFields;\r\n    }\r\n\r\n    /**\r\n     * Gets map of pre-queue times by correlation Id\r\n     *\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {string} correlationId\r\n     * @returns {number}\r\n     */\r\n    getPreQueueTime(eventName: PerformanceEvents, correlationId: string): number | void {\r\n        const preQueueEvent: PreQueueEvent | undefined = this.preQueueTimeByCorrelationId.get(correlationId);\r\n\r\n        if (!preQueueEvent) {\r\n            this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);\r\n            return;\r\n        } else if (preQueueEvent.name !== eventName) {\r\n            this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);\r\n            return;\r\n        }\r\n\r\n        return preQueueEvent.time;\r\n    }\r\n\r\n    /**\r\n     * Calculates the difference between current time and time when function was queued.\r\n     * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\r\n     *\r\n     * @param {number} preQueueTime\r\n     * @param {number} currentTime\r\n     * @returns {number}\r\n     */\r\n    calculateQueuedTime(preQueueTime: number, currentTime: number): number {\r\n        if (preQueueTime < 1) {\r\n            this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);\r\n            return 0;\r\n        }\r\n\r\n        if (currentTime < 1) {\r\n            this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);\r\n            return 0;\r\n        }\r\n\r\n        if (currentTime < preQueueTime) {\r\n            this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\r\n            return 0;\r\n        }\r\n\r\n        return currentTime-preQueueTime;\r\n    }\r\n\r\n    /**\r\n     * Adds queue measurement time to QueueMeasurements array for given correlation ID.\r\n     *\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {?string} correlationId\r\n     * @param {?number} queueTime\r\n     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n     * @returns\r\n     */\r\n    addQueueMeasurement(eventName: PerformanceEvents, correlationId?: string, queueTime?: number, manuallyCompleted?: boolean): void {\r\n        if (!correlationId) {\r\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);\r\n            return;\r\n        }\r\n\r\n        if (queueTime === 0) {\r\n            // Possible for there to be no queue time after calculation\r\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);\r\n        } else if (!queueTime) {\r\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);\r\n            return;\r\n        }\r\n\r\n        const queueMeasurement: QueueMeasurement = {eventName, queueTime, manuallyCompleted};\r\n\r\n        // Adds to existing correlation Id if present in queueMeasurements\r\n        const existingMeasurements = this.queueMeasurements.get(correlationId);\r\n        if (existingMeasurements) {\r\n            existingMeasurements.push(queueMeasurement);\r\n            this.queueMeasurements.set(correlationId, existingMeasurements);\r\n        } else {\r\n            // Sets new correlation Id if not present in queueMeasurements\r\n            this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);\r\n            const measurementArray = [queueMeasurement];\r\n            this.queueMeasurements.set(correlationId, measurementArray);\r\n        }\r\n        // Delete processed pre-queue event.\r\n        this.preQueueTimeByCorrelationId.delete(correlationId);\r\n    }\r\n\r\n    /**\r\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n     *\r\n     * @param {PerformanceEvents} measureName\r\n     * @param {?string} [correlationId]\r\n     * @returns {InProgressPerformanceEvent}\r\n     */\r\n    startMeasurement(measureName: PerformanceEvents, correlationId?: string): InProgressPerformanceEvent {\r\n        // Generate a placeholder correlation if the request does not provide one\r\n        const eventCorrelationId = correlationId || this.generateId();\r\n        if (!correlationId) {\r\n            this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\r\n        }\r\n\r\n        // Duplicate code to address spelling error will be removed at the next major version bump.\r\n        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\r\n        const performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\r\n        performanceMeasurement.startMeasurement();\r\n\r\n        const inProgressEvent: PerformanceEvent = {\r\n            eventId: this.generateId(),\r\n            status: PerformanceEventStatus.InProgress,\r\n            authority: this.authority,\r\n            libraryName: this.libraryName,\r\n            libraryVersion: this.libraryVersion,\r\n            clientId: this.clientId,\r\n            name: measureName,\r\n            startTimeMs: Date.now(),\r\n            correlationId: eventCorrelationId,\r\n            appName: this.applicationTelemetry?.appName,\r\n            appVersion: this.applicationTelemetry?.appVersion,\r\n        };\r\n\r\n        // Store in progress events so they can be discarded if not ended properly\r\n        this.cacheEventByCorrelationId(inProgressEvent);\r\n\r\n        // Return the event and functions the caller can use to properly end/flush the measurement\r\n        return {\r\n            endMeasurement: (event?: Partial<PerformanceEvent>): PerformanceEvent | null => {\r\n                return this.endMeasurement({\r\n                    // Initial set of event properties\r\n                    ...inProgressEvent,\r\n                    // Properties set when event ends\r\n                    ...event\r\n                },\r\n                performanceMeasurement);\r\n            },\r\n            discardMeasurement: () => {\r\n                return this.discardMeasurements(inProgressEvent.correlationId);\r\n            },\r\n            addStaticFields: (fields: StaticFields) => {\r\n                return this.addStaticFields(fields, inProgressEvent.correlationId);\r\n            },\r\n            increment: (counters: Counters) => {\r\n                return this.increment(counters, inProgressEvent.correlationId);\r\n            },\r\n            measurement: performanceMeasurement,\r\n            event: inProgressEvent\r\n        };\r\n\r\n    }\r\n\r\n    /**\r\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n     * as consumers should instead use the function returned by startMeasurement.\r\n     * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\r\n     * otherwise.\r\n     *\r\n     * @param {PerformanceEvent} event\r\n     * @param {IPerformanceMeasurement} measurement\r\n     * @returns {(PerformanceEvent | null)}\r\n     */\r\n    endMeasurement(event: PerformanceEvent, measurement?: IPerformanceMeasurement): PerformanceEvent | null {\r\n        const rootEvent: PerformanceEvent | undefined = this.eventsByCorrelationId.get(event.correlationId);\r\n        if (!rootEvent) {\r\n            this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\r\n            return null;\r\n        }\r\n\r\n        const isRoot = event.eventId === rootEvent.eventId;\r\n        let queueInfo = {\r\n            totalQueueTime: 0,\r\n            totalQueueCount: 0,\r\n            manuallyCompletedCount: 0\r\n        };\r\n        if (isRoot) {\r\n            queueInfo = this.getQueueInfo(event.correlationId);\r\n            this.discardCache(rootEvent.correlationId);\r\n        } else {\r\n            rootEvent.incompleteSubMeasurements?.delete(event.eventId);\r\n        }\r\n\r\n        measurement?.endMeasurement();\r\n        const durationMs = measurement?.flushMeasurement();\r\n        // null indicates no measurement was taken (e.g. needed performance APIs not present)\r\n        if (!durationMs) {\r\n            this.logger.trace(\"PerformanceClient: Performance measurement not taken\", rootEvent.correlationId);\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`, event.correlationId);\r\n\r\n        // Add sub-measurement attribute to root event.\r\n        if (!isRoot) {\r\n            rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\r\n            return { ...rootEvent };\r\n        }\r\n\r\n        let finalEvent: PerformanceEvent = { ...rootEvent, ...event };\r\n        let incompleteSubsCount: number = 0;\r\n        // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\r\n        finalEvent.incompleteSubMeasurements?.forEach(subMeasurement => {\r\n            this.logger.trace(`PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`, finalEvent.correlationId);\r\n            incompleteSubsCount++;\r\n        });\r\n        finalEvent.incompleteSubMeasurements = undefined;\r\n\r\n        finalEvent = {\r\n            ...finalEvent,\r\n            durationMs: Math.round(durationMs),\r\n            queuedTimeMs: queueInfo.totalQueueTime,\r\n            queuedCount: queueInfo.totalQueueCount,\r\n            queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\r\n            status: PerformanceEventStatus.Completed,\r\n            incompleteSubsCount\r\n        };\r\n        this.truncateIntegralFields(finalEvent, this.getIntFields());\r\n        this.emitEvents([finalEvent], event.correlationId);\r\n\r\n        return finalEvent;\r\n    }\r\n\r\n    /**\r\n     * Saves extra information to be emitted when the measurements are flushed\r\n     * @param fields\r\n     * @param correlationId\r\n     */\r\n    addStaticFields(fields: StaticFields, correlationId: string) : void {\r\n        this.logger.trace(\"PerformanceClient: Updating static fields\");\r\n        const event = this.eventsByCorrelationId.get(correlationId);\r\n        if (event) {\r\n            this.eventsByCorrelationId.set(correlationId, {...event, ...fields});\r\n        } else {\r\n            this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increment counters to be emitted when the measurements are flushed\r\n     * @param counters {Counters}\r\n     * @param correlationId {string} correlation identifier\r\n     */\r\n    increment(counters: Counters, correlationId: string): void {\r\n        this.logger.trace(\"PerformanceClient: Updating counters\");\r\n        const event = this.eventsByCorrelationId.get(correlationId);\r\n        if (event) {\r\n            for (const counter in counters) {\r\n                if (!event.hasOwnProperty(counter)) {\r\n                    event[counter] = 0;\r\n                }\r\n                event[counter] += counters[counter];\r\n            }\r\n        } else {\r\n            this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Upserts event into event cache.\r\n     * First key is the correlation id, second key is the event id.\r\n     * Allows for events to be grouped by correlation id,\r\n     * and to easily allow for properties on them to be updated.\r\n     *\r\n     * @private\r\n     * @param {PerformanceEvent} event\r\n     */\r\n    private cacheEventByCorrelationId(event: PerformanceEvent) {\r\n        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\r\n        if (rootEvent) {\r\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\r\n            rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\r\n            rootEvent.incompleteSubMeasurements.set(event.eventId, {name: event.name, startTimeMs: event.startTimeMs });\r\n        } else {\r\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\r\n            this.eventsByCorrelationId.set(event.correlationId, { ...event });\r\n        }\r\n    }\r\n\r\n    private getQueueInfo(correlationId: string): { totalQueueTime: number, totalQueueCount: number, manuallyCompletedCount: number } {\r\n        const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\r\n        if (!queueMeasurementForCorrelationId) {\r\n            this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);\r\n        }\r\n\r\n        let totalQueueTime = 0;\r\n        let totalQueueCount = 0;\r\n        let manuallyCompletedCount = 0;\r\n        queueMeasurementForCorrelationId?.forEach((measurement) => {\r\n            totalQueueTime += measurement.queueTime;\r\n            totalQueueCount++;\r\n            manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\r\n        });\r\n\r\n        return {\r\n            totalQueueTime,\r\n            totalQueueCount,\r\n            manuallyCompletedCount\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Removes measurements for a given correlation id.\r\n     *\r\n     * @param {string} correlationId\r\n     */\r\n    discardMeasurements(correlationId: string): void {\r\n        this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\r\n        this.eventsByCorrelationId.delete(correlationId);\r\n    }\r\n\r\n    /**\r\n     * Removes cache for a given correlation id.\r\n     *\r\n     * @param {string} correlationId correlation identifier\r\n     */\r\n    private discardCache(correlationId: string): void {\r\n        this.discardMeasurements(correlationId);\r\n\r\n        this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\r\n        this.queueMeasurements.delete(correlationId);\r\n\r\n        this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\r\n        this.preQueueTimeByCorrelationId.delete(correlationId);\r\n    }\r\n\r\n    /**\r\n     * Registers a callback function to receive performance events.\r\n     *\r\n     * @param {PerformanceCallbackFunction} callback\r\n     * @returns {string}\r\n     */\r\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\r\n        const callbackId = this.generateId();\r\n        this.callbacks.set(callbackId, callback);\r\n        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\r\n\r\n        return callbackId;\r\n    }\r\n\r\n    /**\r\n     * Removes a callback registered with addPerformanceCallback.\r\n     *\r\n     * @param {string} callbackId\r\n     * @returns {boolean}\r\n     */\r\n    removePerformanceCallback(callbackId: string): boolean {\r\n        const result = this.callbacks.delete(callbackId);\r\n\r\n        if (result) {\r\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\r\n        } else {\r\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Emits events to all registered callbacks.\r\n     *\r\n     * @param {PerformanceEvent[]} events\r\n     * @param {?string} [correlationId]\r\n     */\r\n    emitEvents(events: PerformanceEvent[], correlationId: string): void {\r\n        this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\r\n\r\n        this.callbacks.forEach((callback: PerformanceCallbackFunction, callbackId: string) => {\r\n            this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\r\n            callback.apply(null, [events]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enforce truncation of integral fields in performance event.\r\n     * @param {PerformanceEvent} event performance event to update.\r\n     * @param {Set<string>} intFields integral fields.\r\n     */\r\n    private truncateIntegralFields(event: PerformanceEvent, intFields: ReadonlySet<string>): void {\r\n        intFields.forEach((key) => {\r\n            if (key in event && typeof event[key] === \"number\") {\r\n                event[key] = Math.floor(event[key]);\r\n            }\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}