{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { ClientAuthError } from '../error/ClientAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * @hidden\r\n */\n\nvar StringUtils =\n/** @class */\nfunction () {\n  function StringUtils() {}\n  /**\r\n   * decode a JWT\r\n   *\r\n   * @param authToken\r\n   */\n\n\n  StringUtils.decodeAuthToken = function (authToken) {\n    if (StringUtils.isEmpty(authToken)) {\n      throw ClientAuthError.createTokenNullOrEmptyError(authToken);\n    }\n\n    var tokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n    var matches = tokenPartsRegex.exec(authToken);\n\n    if (!matches || matches.length < 4) {\n      throw ClientAuthError.createTokenParsingError(\"Given token is malformed: \" + JSON.stringify(authToken));\n    }\n\n    var crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n    return crackedToken;\n  };\n  /**\r\n   * Check if a string is empty.\r\n   *\r\n   * @param str\r\n   */\n\n\n  StringUtils.isEmpty = function (str) {\n    return typeof str === \"undefined\" || !str || 0 === str.length;\n  };\n  /**\r\n   * Check if stringified object is empty\r\n   * @param strObj\r\n   */\n\n\n  StringUtils.isEmptyObj = function (strObj) {\n    if (strObj && !StringUtils.isEmpty(strObj)) {\n      try {\n        var obj = JSON.parse(strObj);\n        return Object.keys(obj).length === 0;\n      } catch (e) {}\n    }\n\n    return true;\n  };\n\n  StringUtils.startsWith = function (str, search) {\n    return str.indexOf(search) === 0;\n  };\n\n  StringUtils.endsWith = function (str, search) {\n    return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;\n  };\n  /**\r\n   * Parses string into an object.\r\n   *\r\n   * @param query\r\n   */\n\n\n  StringUtils.queryStringToObject = function (query) {\n    var obj = {};\n    var params = query.split(\"&\");\n\n    var decode = function (s) {\n      return decodeURIComponent(s.replace(/\\+/g, \" \"));\n    };\n\n    params.forEach(function (pair) {\n      if (pair.trim()) {\n        var _a = pair.split(/=(.+)/g, 2),\n            key = _a[0],\n            value = _a[1]; // Split on the first occurence of the '=' character\n\n\n        if (key && value) {\n          obj[decode(key)] = decode(value);\n        }\n      }\n    });\n    return obj;\n  };\n  /**\r\n   * Trims entries in an array.\r\n   *\r\n   * @param arr\r\n   */\n\n\n  StringUtils.trimArrayEntries = function (arr) {\n    return arr.map(function (entry) {\n      return entry.trim();\n    });\n  };\n  /**\r\n   * Removes empty strings from array\r\n   * @param arr\r\n   */\n\n\n  StringUtils.removeEmptyStringsFromArray = function (arr) {\n    return arr.filter(function (entry) {\n      return !StringUtils.isEmpty(entry);\n    });\n  };\n  /**\r\n   * Attempts to parse a string into JSON\r\n   * @param str\r\n   */\n\n\n  StringUtils.jsonParseHelper = function (str) {\n    try {\n      return JSON.parse(str);\n    } catch (e) {\n      return null;\n    }\n  };\n  /**\r\n   * Tests if a given string matches a given pattern, with support for wildcards and queries.\r\n   * @param pattern Wildcard pattern to string match. Supports \"*\" for wildcards and \"?\" for queries\r\n   * @param input String to match against\r\n   */\n\n\n  StringUtils.matchPattern = function (pattern, input) {\n    /**\r\n     * Wildcard support: https://stackoverflow.com/a/3117248/4888559\r\n     * Queries: replaces \"?\" in string with escaped \"\\?\" for regex test\r\n     */\n    var regex = new RegExp(pattern.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\*/g, \"[^ ]*\").replace(/\\?/g, \"\\\\\\?\")); // eslint-disable-line security/detect-non-literal-regexp\n\n    return regex.test(input);\n  };\n\n  return StringUtils;\n}();\n\nexport { StringUtils };","map":{"version":3,"sources":["../../src/utils/StringUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { DecodedAuthToken } from \"../account/DecodedAuthToken\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport class StringUtils {\r\n\r\n    /**\r\n     * decode a JWT\r\n     *\r\n     * @param authToken\r\n     */\r\n    static decodeAuthToken(authToken: string): DecodedAuthToken {\r\n        if (StringUtils.isEmpty(authToken)) {\r\n            throw ClientAuthError.createTokenNullOrEmptyError(authToken);\r\n        }\r\n        const tokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\r\n        const matches = tokenPartsRegex.exec(authToken);\r\n        if (!matches || matches.length < 4) {\r\n            throw ClientAuthError.createTokenParsingError(`Given token is malformed: ${JSON.stringify(authToken)}`);\r\n        }\r\n        const crackedToken: DecodedAuthToken = {\r\n            header: matches[1],\r\n            JWSPayload: matches[2],\r\n            JWSSig: matches[3]\r\n        };\r\n        return crackedToken;\r\n    }\r\n\r\n    /**\r\n     * Check if a string is empty.\r\n     *\r\n     * @param str\r\n     */\r\n    static isEmpty(str?: string): boolean {\r\n        return (typeof str === \"undefined\" || !str || 0 === str.length);\r\n    }\r\n\r\n    /**\r\n     * Check if stringified object is empty\r\n     * @param strObj \r\n     */\r\n    static isEmptyObj(strObj?: string): boolean {\r\n        if (strObj && !StringUtils.isEmpty(strObj)) {\r\n            try {\r\n                const obj = JSON.parse(strObj);\r\n                return Object.keys(obj).length === 0;\r\n            } catch (e) {}\r\n        }\r\n        return true;\r\n    }\r\n\r\n    static startsWith(str: string, search: string): boolean {\r\n        return str.indexOf(search) === 0;\r\n    }\r\n\r\n    static endsWith(str: string, search: string): boolean {\r\n        return (str.length >= search.length) && (str.lastIndexOf(search) === (str.length - search.length));\r\n    }\r\n\r\n    /**\r\n     * Parses string into an object.\r\n     *\r\n     * @param query\r\n     */\r\n    static queryStringToObject<T>(query: string): T {\r\n        const obj: {} = {};\r\n        const params = query.split(\"&\");\r\n        const decode = (s: string) => decodeURIComponent(s.replace(/\\+/g, \" \"));\r\n        params.forEach((pair) => {\r\n            if (pair.trim()) {\r\n                const [key, value] = pair.split(/=(.+)/g, 2); // Split on the first occurence of the '=' character\r\n                if (key && value) {\r\n                    obj[decode(key)] = decode(value);\r\n                }\r\n            }\r\n        });\r\n        return obj as T;\r\n    }\r\n\r\n    /**\r\n     * Trims entries in an array.\r\n     *\r\n     * @param arr\r\n     */\r\n    static trimArrayEntries(arr: Array<string>): Array<string> {\r\n        return arr.map(entry => entry.trim());\r\n    }\r\n\r\n    /**\r\n     * Removes empty strings from array\r\n     * @param arr\r\n     */\r\n    static removeEmptyStringsFromArray(arr: Array<string>): Array<string> {\r\n        return arr.filter(entry => {\r\n            return !StringUtils.isEmpty(entry);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Attempts to parse a string into JSON\r\n     * @param str\r\n     */\r\n    static jsonParseHelper<T>(str: string): T | null {\r\n        try {\r\n            return JSON.parse(str) as T;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests if a given string matches a given pattern, with support for wildcards and queries.\r\n     * @param pattern Wildcard pattern to string match. Supports \"*\" for wildcards and \"?\" for queries\r\n     * @param input String to match against\r\n     */\r\n    static matchPattern(pattern: string, input: string): boolean {\r\n        /**\r\n         * Wildcard support: https://stackoverflow.com/a/3117248/4888559\r\n         * Queries: replaces \"?\" in string with escaped \"\\?\" for regex test\r\n         */\r\n        const regex: RegExp = new RegExp(pattern.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\*/g, \"[^ ]*\").replace(/\\?/g, \"\\\\\\?\")); // eslint-disable-line security/detect-non-literal-regexp\r\n\r\n        return regex.test(input);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}