{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { __extends, __awaiter, __assign, __generator, __spreadArrays } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { Separators, AADServerParamKeys, AuthenticationScheme, GrantType, PromptValue, HeaderNames } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.js';\nimport { CcsCredentialType } from '../account/CcsCredential.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { RequestValidator } from '../request/RequestValidator.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\n\nvar AuthorizationCodeClient =\n/** @class */\nfunction (_super) {\n  __extends(AuthorizationCodeClient, _super);\n\n  function AuthorizationCodeClient(configuration, performanceClient) {\n    var _this = _super.call(this, configuration, performanceClient) || this; // Flag to indicate if client is for hybrid spa auth code redemption\n\n\n    _this.includeRedirectUri = true;\n    return _this;\n  }\n  /**\r\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n   * application. The URL target the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * acquireToken(AuthorizationCodeRequest)\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getAuthCodeUrl = function (request) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var queryString;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n            return [4\n            /*yield*/\n            , this.createAuthCodeUrlQueryString(request)];\n\n          case 1:\n            queryString = _c.sent();\n            return [2\n            /*return*/\n            , UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];\n        }\n      });\n    });\n  };\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.acquireToken = function (request, authCodePayload) {\n    var _a, _b, _c, _d, _e, _f;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var atsMeasurement, reqTimestamp, response, requestId, httpVerAuthority, responseHandler;\n\n      var _this = this;\n\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            if (!request || !request.code) {\n              throw ClientAuthError.createTokenRequestCannotBeMadeError();\n            }\n\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n            atsMeasurement = (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.startMeasurement(\"AuthCodeClientAcquireToken\", request.correlationId);\n            this.logger.info(\"in acquireToken call in auth-code client\");\n            reqTimestamp = TimeUtils.nowSeconds();\n            (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n            return [4\n            /*yield*/\n            , this.executeTokenRequest(this.authority, request)];\n\n          case 1:\n            response = _g.sent();\n            requestId = (_d = response.headers) === null || _d === void 0 ? void 0 : _d[HeaderNames.X_MS_REQUEST_ID];\n            httpVerAuthority = (_e = response.headers) === null || _e === void 0 ? void 0 : _e[HeaderNames.X_MS_HTTP_VERSION];\n\n            if (httpVerAuthority) {\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({\n                httpVerAuthority: httpVerAuthority\n              });\n            }\n\n            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient); // Validate response. This function throws a server error if an error is returned by the server.\n\n            responseHandler.validateTokenResponse(response.body);\n            (_f = this.performanceClient) === null || _f === void 0 ? void 0 : _f.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);\n            return [2\n            /*return*/\n            , responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId).then(function (result) {\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({\n                success: true\n              });\n              return result;\n            }).catch(function (error) {\n              _this.logger.verbose(\"Error in fetching token in ACC\", request.correlationId);\n\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({\n                errorCode: error.errorCode,\n                subErrorCode: error.subError,\n                success: false\n              });\n              throw error;\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Handles the hash fragment response from public client code request. Returns a code response used by\r\n   * the client to exchange for a token in acquireToken.\r\n   * @param hashFragment\r\n   */\n\n\n  AuthorizationCodeClient.prototype.handleFragmentResponse = function (hashFragment, cachedState) {\n    // Handle responses.\n    var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null); // Deserialize hash fragment response parameters.\n\n    var hashUrlString = new UrlString(hashFragment); // Deserialize hash fragment response parameters.\n\n    var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash()); // Get code response\n\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils); // throw when there is no auth code in the response\n\n    if (!serverParams.code) {\n      throw ClientAuthError.createNoAuthCodeInServerResponseError();\n    }\n\n    return __assign(__assign({}, serverParams), {\n      // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\n      code: serverParams.code\n    });\n  };\n  /**\r\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getLogoutUri = function (logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw ClientConfigurationError.createEmptyLogoutRequestError();\n    }\n\n    var queryString = this.createLogoutUrlQueryString(logoutRequest); // Construct logout URI\n\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  };\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.executeTokenRequest = function (authority, request) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var queryParametersString, endpoint, requestBody, ccsCredential, clientInfo, headers, thumbprint;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n            queryParametersString = this.createTokenQueryParameters(request);\n            endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n            return [4\n            /*yield*/\n            , this.createTokenRequestBody(request)];\n\n          case 1:\n            requestBody = _c.sent();\n            ccsCredential = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCredential = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            }\n\n            headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: authority.canonicalAuthority,\n              scopes: request.scopes,\n              claims: request.claims,\n              authenticationScheme: request.authenticationScheme,\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              sshKid: request.sshKid\n            };\n            return [2\n            /*return*/\n            , this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createTokenRequestBody = function (request) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;\n\n      var _c;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            /*\r\n             * For hybrid spa flow, there will be a code but no verifier\r\n             * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n             */\n\n            if (!this.includeRedirectUri) {\n              // Just validate\n              RequestValidator.validateRedirectUri(request.redirectUri);\n            } else {\n              // Validate and include redirect uri\n              parameterBuilder.addRedirectUri(request.redirectUri);\n            } // Add scope array, parameter builder will add default scopes and dedupe\n\n\n            parameterBuilder.addScopes(request.scopes); // add code: user set, not validated\n\n            parameterBuilder.addAuthorizationCode(request.code); // Add library metadata\n\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n            parameterBuilder.addThrottling();\n\n            if (this.serverTelemetryManager) {\n              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n            } // add code_verifier if passed\n\n\n            if (request.codeVerifier) {\n              parameterBuilder.addCodeVerifier(request.codeVerifier);\n            }\n\n            if (this.config.clientCredentials.clientSecret) {\n              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n            }\n\n            if (this.config.clientCredentials.clientAssertion) {\n              clientAssertion = this.config.clientCredentials.clientAssertion;\n              parameterBuilder.addClientAssertion(clientAssertion.assertion);\n              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n            }\n\n            parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n            parameterBuilder.addClientInfo();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            reqCnfData = _d.sent(); // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            if (request.authenticationScheme === AuthenticationScheme.SSH) {\n              if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n              } else {\n                throw ClientConfigurationError.createMissingSshJwkError();\n              }\n            }\n\n            _d.label = 3;\n\n          case 3:\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId);\n\n            if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            ccsCred = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCred = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            } else {\n              ccsCred = request.ccsCredential;\n            } // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n\n\n            if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n              switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n\n                  break;\n\n                case CcsCredentialType.UPN:\n                  parameterBuilder.addCcsUpn(ccsCred.credential);\n                  break;\n              }\n            }\n\n            if (request.tokenBodyParameters) {\n              parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n            } // Add hybrid spa parameters if not already provided\n\n\n            if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\n              parameterBuilder.addExtraQueryParameters((_c = {}, _c[AADServerParamKeys.RETURN_SPA_CODE] = \"1\", _c));\n            }\n\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function (request) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);\n            parameterBuilder.addScopes(requestScopes); // validate the redirectUri (to be a non null value)\n\n            parameterBuilder.addRedirectUri(request.redirectUri);\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId); // add response_mode. If not passed in it defaults to query.\n\n            parameterBuilder.addResponseMode(request.responseMode); // add response_type = code\n\n            parameterBuilder.addResponseTypeCode(); // add library info parameters\n\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application); // add client_info=1\n\n            parameterBuilder.addClientInfo();\n\n            if (request.codeChallenge && request.codeChallengeMethod) {\n              parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n            }\n\n            if (request.prompt) {\n              parameterBuilder.addPrompt(request.prompt);\n            }\n\n            if (request.domainHint) {\n              parameterBuilder.addDomainHint(request.domainHint);\n            } // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n\n\n            if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n              // AAD will throw if prompt=select_account is passed with an account hint\n              if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n                parameterBuilder.addSid(request.sid);\n              } else if (request.account) {\n                accountSid = this.extractAccountSid(request.account);\n                accountLoginHintClaim = this.extractLoginHint(request.account); // If login_hint claim is present, use it over sid/username\n\n                if (accountLoginHintClaim) {\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n                  parameterBuilder.addLoginHint(accountLoginHintClaim);\n\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\n                  /*\r\n                   * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n                   * SessionId is only used in silent calls\r\n                   */\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n                  parameterBuilder.addSid(accountSid);\n\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                } else if (request.loginHint) {\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n                  parameterBuilder.addLoginHint(request.loginHint);\n                  parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                  // Fallback to account username if provided\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n                  parameterBuilder.addLoginHint(request.account.username);\n\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                }\n              } else if (request.loginHint) {\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n              }\n            } else {\n              this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n            }\n\n            if (request.nonce) {\n              parameterBuilder.addNonce(request.nonce);\n            }\n\n            if (request.state) {\n              parameterBuilder.addState(request.state);\n            }\n\n            if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            if (request.extraQueryParameters) {\n              parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n            }\n\n            if (!request.nativeBroker) return [3\n            /*break*/\n            , 2]; // signal ests that this is a WAM call\n\n            parameterBuilder.addNativeBroker();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            reqCnfData = _b.sent();\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n            _b.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n   * @param account\r\n   */\n\n\n  AuthorizationCodeClient.prototype.extractAccountSid = function (account) {\n    var _a;\n\n    return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.sid) || null;\n  };\n\n  AuthorizationCodeClient.prototype.extractLoginHint = function (account) {\n    var _a;\n\n    return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.login_hint) || null;\n  };\n\n  return AuthorizationCodeClient;\n}(BaseClient);\n\nexport { AuthorizationCodeClient };","map":{"version":3,"sources":["../../src/client/AuthorizationCodeClient.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest\";\r\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\r\nimport { GrantType, AuthenticationScheme, PromptValue, Separators, AADServerParamKeys, HeaderNames } from \"../utils/Constants\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { UrlString } from \"../url/UrlString\";\r\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse\";\r\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest\";\r\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\r\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\r\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\nimport { buildClientInfoFromHomeAccountId, buildClientInfo } from \"../account/ClientInfo\";\r\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { RequestValidator } from \"../request/RequestValidator\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\r\n\r\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\r\nexport class AuthorizationCodeClient extends BaseClient {\r\n    // Flag to indicate if client is for hybrid spa auth code redemption\r\n    protected includeRedirectUri: boolean = true;\r\n\r\n    constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient) {\r\n        super(configuration, performanceClient);\r\n    }\r\n\r\n    /**\r\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n     * application. The URL target the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * acquireToken(AuthorizationCodeRequest)\r\n     * @param request\r\n     */\r\n    async getAuthCodeUrl(request: CommonAuthorizationUrlRequest): Promise<string> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\r\n\r\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\r\n        const queryString = await this.createAuthCodeUrlQueryString(request);\r\n\r\n        return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);\r\n    }\r\n\r\n    /**\r\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n     * authorization_code_grant\r\n     * @param request\r\n     */\r\n    async acquireToken(request: CommonAuthorizationCodeRequest, authCodePayload?: AuthorizationCodePayload): Promise<AuthenticationResult> {\r\n        if (!request || !request.code) {\r\n            throw ClientAuthError.createTokenRequestCannotBeMadeError();\r\n        }\r\n\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\r\n        \r\n        // @ts-ignore\r\n        const atsMeasurement = this.performanceClient?.startMeasurement(\"AuthCodeClientAcquireToken\", request.correlationId);\r\n        this.logger.info(\"in acquireToken call in auth-code client\");\r\n\r\n        const reqTimestamp = TimeUtils.nowSeconds();\r\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\r\n        const response = await this.executeTokenRequest(this.authority, request);\r\n\r\n        // Retrieve requestId from response headers\r\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\r\n        const httpVerAuthority = response.headers?.[HeaderNames.X_MS_HTTP_VERSION];\r\n        if(httpVerAuthority)\r\n        {\r\n            atsMeasurement?.addStaticFields({\r\n                httpVerAuthority\r\n            });\r\n        }\r\n        const responseHandler = new ResponseHandler(\r\n            this.config.authOptions.clientId,\r\n            this.cacheManager,\r\n            this.cryptoUtils,\r\n            this.logger,\r\n            this.config.serializableCache,\r\n            this.config.persistencePlugin,\r\n            this.performanceClient\r\n        );\r\n\r\n        // Validate response. This function throws a server error if an error is returned by the server.\r\n        responseHandler.validateTokenResponse(response.body);\r\n\r\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);\r\n        return responseHandler.handleServerTokenResponse(\r\n            response.body,\r\n            this.authority,\r\n            reqTimestamp,\r\n            request,\r\n            authCodePayload,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            requestId\r\n        ).then((result: AuthenticationResult) => {\r\n            atsMeasurement?.endMeasurement({\r\n                success: true\r\n            });\r\n            return result;\r\n        })\r\n            .catch((error) => {\r\n                this.logger.verbose(\"Error in fetching token in ACC\", request.correlationId);\r\n                atsMeasurement?.endMeasurement({\r\n                    errorCode: error.errorCode,\r\n                    subErrorCode: error.subError,\r\n                    success: false\r\n                });\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Handles the hash fragment response from public client code request. Returns a code response used by\r\n     * the client to exchange for a token in acquireToken.\r\n     * @param hashFragment\r\n     */\r\n    handleFragmentResponse(hashFragment: string, cachedState: string): AuthorizationCodePayload {\r\n        // Handle responses.\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\r\n\r\n        // Deserialize hash fragment response parameters.\r\n        const hashUrlString = new UrlString(hashFragment);\r\n        // Deserialize hash fragment response parameters.\r\n        const serverParams: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hashUrlString.getHash());\r\n\r\n        // Get code response\r\n        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);\r\n\r\n        // throw when there is no auth code in the response\r\n        if (!serverParams.code) {\r\n            throw ClientAuthError.createNoAuthCodeInServerResponseError();\r\n        }\r\n        return {\r\n            ...serverParams,\r\n            // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\r\n            code: serverParams.code\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n     * Default behaviour is to redirect the user to `window.location.href`.\r\n     * @param authorityUri\r\n     */\r\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\r\n        // Throw error if logoutRequest is null/undefined\r\n        if (!logoutRequest) {\r\n            throw ClientConfigurationError.createEmptyLogoutRequestError();\r\n        }\r\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\r\n\r\n        // Construct logout URI\r\n        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\r\n    }\r\n\r\n    /**\r\n     * Executes POST request to token endpoint\r\n     * @param authority\r\n     * @param request\r\n     */\r\n    private async executeTokenRequest(authority: Authority, request: CommonAuthorizationCodeRequest): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\r\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\r\n        \r\n        const queryParametersString = this.createTokenQueryParameters(request);\r\n        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\r\n        \r\n        const requestBody = await this.createTokenRequestBody(request);\r\n        \r\n        let ccsCredential: CcsCredential | undefined = undefined;\r\n        if (request.clientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\r\n                ccsCredential = {\r\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\r\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\r\n                };\r\n            } catch (e) {\r\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\r\n            }\r\n        }\r\n        const headers: Record<string, string> = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\r\n\r\n        const thumbprint: RequestThumbprint = {\r\n            clientId: this.config.authOptions.clientId,\r\n            authority: authority.canonicalAuthority,\r\n            scopes: request.scopes,\r\n            claims: request.claims,\r\n            authenticationScheme: request.authenticationScheme,\r\n            resourceRequestMethod: request.resourceRequestMethod,\r\n            resourceRequestUri: request.resourceRequestUri,\r\n            shrClaims: request.shrClaims,\r\n            sshKid: request.sshKid\r\n        };\r\n\r\n        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint);\r\n    }\r\n\r\n    /**\r\n     * Generates a map for all the params to be sent to the service\r\n     * @param request\r\n     */\r\n    private async createTokenRequestBody(request: CommonAuthorizationCodeRequest): Promise<string> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\r\n\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        /*\r\n         * For hybrid spa flow, there will be a code but no verifier\r\n         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n         */\r\n        if (!this.includeRedirectUri) {\r\n            // Just validate\r\n            RequestValidator.validateRedirectUri(request.redirectUri);\r\n        } else {\r\n            // Validate and include redirect uri\r\n            parameterBuilder.addRedirectUri(request.redirectUri);\r\n        }\r\n\r\n        // Add scope array, parameter builder will add default scopes and dedupe\r\n        parameterBuilder.addScopes(request.scopes);\r\n\r\n        // add code: user set, not validated\r\n        parameterBuilder.addAuthorizationCode(request.code);\r\n\r\n        // Add library metadata\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\r\n        parameterBuilder.addThrottling();\r\n\r\n        if (this.serverTelemetryManager) {\r\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\r\n        }\r\n\r\n        // add code_verifier if passed\r\n        if (request.codeVerifier) {\r\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\r\n        }\r\n\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\r\n        }\r\n\r\n        if (this.config.clientCredentials.clientAssertion) {\r\n            const clientAssertion = this.config.clientCredentials.clientAssertion;\r\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\r\n            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\r\n        }\r\n\r\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\r\n        parameterBuilder.addClientInfo();\r\n\r\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\r\n            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\r\n\r\n            this.performanceClient?.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);\r\n            const reqCnfData = await popTokenGenerator.generateCnf(request);\r\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\r\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\r\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\r\n            if (request.sshJwk) {\r\n                parameterBuilder.addSshJwk(request.sshJwk);\r\n            } else {\r\n                throw ClientConfigurationError.createMissingSshJwkError();\r\n            }\r\n        }\r\n\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\r\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n\r\n        let ccsCred: CcsCredential | undefined = undefined;\r\n        if (request.clientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\r\n                ccsCred = {\r\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\r\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\r\n                };\r\n            } catch (e) {\r\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\r\n            }\r\n        } else {\r\n            ccsCred = request.ccsCredential;\r\n        }\r\n\r\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\r\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\r\n            switch (ccsCred.type) {\r\n                case CcsCredentialType.HOME_ACCOUNT_ID:\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\r\n                    }\r\n                    break;\r\n                case CcsCredentialType.UPN:\r\n                    parameterBuilder.addCcsUpn(ccsCred.credential);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (request.tokenBodyParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\r\n        }\r\n\r\n        // Add hybrid spa parameters if not already provided\r\n        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\r\n            parameterBuilder.addExtraQueryParameters({\r\n                [AADServerParamKeys.RETURN_SPA_CODE]: \"1\"\r\n            });\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n     * @param request\r\n     */\r\n    private async createAuthCodeUrlQueryString(request: CommonAuthorizationUrlRequest): Promise<string> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\r\n\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        const requestScopes = [...request.scopes || [], ...request.extraScopesToConsent || []];\r\n        parameterBuilder.addScopes(requestScopes);\r\n\r\n        // validate the redirectUri (to be a non null value)\r\n        parameterBuilder.addRedirectUri(request.redirectUri);\r\n\r\n        // generate the correlationId if not set by the user and add\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        // add response_mode. If not passed in it defaults to query.\r\n        parameterBuilder.addResponseMode(request.responseMode);\r\n\r\n        // add response_type = code\r\n        parameterBuilder.addResponseTypeCode();\r\n\r\n        // add library info parameters\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\r\n\r\n        // add client_info=1\r\n        parameterBuilder.addClientInfo();\r\n\r\n        if (request.codeChallenge && request.codeChallengeMethod) {\r\n            parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\r\n        }\r\n\r\n        if (request.prompt) {\r\n            parameterBuilder.addPrompt(request.prompt);\r\n        }\r\n\r\n        if (request.domainHint) {\r\n            parameterBuilder.addDomainHint(request.domainHint);\r\n        }\r\n\r\n        // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\r\n        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\r\n            // AAD will throw if prompt=select_account is passed with an account hint\r\n            if (request.sid && request.prompt === PromptValue.NONE) {\r\n                // SessionID is only used in silent calls\r\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\r\n                parameterBuilder.addSid(request.sid);\r\n            } else if (request.account) {\r\n                const accountSid = this.extractAccountSid(request.account);\r\n                const accountLoginHintClaim = this.extractLoginHint(request.account);\r\n                // If login_hint claim is present, use it over sid/username\r\n                if (accountLoginHintClaim) {\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\r\n                    parameterBuilder.addLoginHint(accountLoginHintClaim);\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\r\n                    }\r\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\r\n                    /*\r\n                     * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n                     * SessionId is only used in silent calls\r\n                     */\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\r\n                    parameterBuilder.addSid(accountSid);\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\r\n                    }\r\n                } else if (request.loginHint) {\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\r\n                    parameterBuilder.addLoginHint(request.loginHint);\r\n                    parameterBuilder.addCcsUpn(request.loginHint);\r\n                } else if (request.account.username) {\r\n                    // Fallback to account username if provided\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\r\n                    parameterBuilder.addLoginHint(request.account.username);\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\r\n                    }\r\n                }\r\n            } else if (request.loginHint) {\r\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\r\n                parameterBuilder.addLoginHint(request.loginHint);\r\n                parameterBuilder.addCcsUpn(request.loginHint);\r\n            }\r\n        } else {\r\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\r\n        }\r\n\r\n        if (request.nonce) {\r\n            parameterBuilder.addNonce(request.nonce);\r\n        }\r\n\r\n        if (request.state) {\r\n            parameterBuilder.addState(request.state);\r\n        }\r\n\r\n        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\r\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n\r\n        if (request.extraQueryParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\r\n        }\r\n\r\n        if (request.nativeBroker) {\r\n            // signal ests that this is a WAM call\r\n            parameterBuilder.addNativeBroker();\r\n\r\n            // pass the req_cnf for POP\r\n            if (request.authenticationScheme === AuthenticationScheme.POP) {\r\n                const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\r\n                // to reduce the URL length, it is recommended to send the short form of the req_cnf\r\n                const reqCnfData = await popTokenGenerator.generateCnf(request);\r\n                parameterBuilder.addPopToken(reqCnfData.reqCnfString);\r\n            }\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * This API validates the `EndSessionRequest` and creates a URL\r\n     * @param request\r\n     */\r\n    private createLogoutUrlQueryString(request: CommonEndSessionRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        if (request.postLogoutRedirectUri) {\r\n            parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\r\n        }\r\n\r\n        if (request.correlationId) {\r\n            parameterBuilder.addCorrelationId(request.correlationId);\r\n        }\r\n\r\n        if (request.idTokenHint) {\r\n            parameterBuilder.addIdTokenHint(request.idTokenHint);\r\n        }\r\n\r\n        if (request.state) {\r\n            parameterBuilder.addState(request.state);\r\n        }\r\n\r\n        if (request.logoutHint) {\r\n            parameterBuilder.addLogoutHint(request.logoutHint);\r\n        }\r\n\r\n        if (request.extraQueryParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n     * @param account\r\n     */\r\n    private extractAccountSid(account: AccountInfo): string | null {\r\n        return account.idTokenClaims?.sid || null;\r\n    }\r\n\r\n    private extractLoginHint(account: AccountInfo): string | null {\r\n        return account.idTokenClaims?.login_hint || null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}