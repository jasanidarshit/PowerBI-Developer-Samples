{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __spread, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar MsrBrowserCrypto =\n/** @class */\nfunction () {\n  function MsrBrowserCrypto() {}\n\n  MsrBrowserCrypto.prototype.initPrng = function (entropy) {\n    // Turn into array, as initPrng seems to not always like Uint8Array (even though it should support both)\n    return window.msrCrypto.initPrng(__spread(entropy));\n  };\n\n  MsrBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    return window.msrCrypto.getRandomValues(dataBuffer);\n  };\n\n  MsrBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.generateKey(algorithm, extractable, keyUsages)];\n      });\n    });\n  };\n\n  MsrBrowserCrypto.prototype.exportKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.exportKey(KEY_FORMAT_JWK, key)];\n      });\n    });\n  };\n\n  MsrBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.importKey(KEY_FORMAT_JWK, keyData, algorithm, extractable, keyUsages)];\n      });\n    });\n  };\n\n  MsrBrowserCrypto.prototype.sign = function (algorithm, key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.sign(algorithm, key, data)];\n      });\n    });\n  };\n\n  MsrBrowserCrypto.prototype.digest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.msrCrypto.subtle.digest(algorithm, data)];\n      });\n    });\n  };\n\n  return MsrBrowserCrypto;\n}();\n\nexport { MsrBrowserCrypto };","map":{"version":3,"sources":["../../src/crypto/MsrBrowserCrypto.ts"],"names":[],"mappings":";;;;;AAAA;;;AAGG;;AAaH,IAAA,gBAAA;AAAA;AAAA,YAAA;AAAA,WAAA,gBAAA,GAAA,CA6BC;;AA5BG,EAAA,gBAAQ,CAAA,SAAR,CAAQ,QAAR,GAAA,UAAS,OAAT,EAA6B;;AAEzB,WAAO,MAAM,CAAC,SAAP,CAAiB,QAAjB,CAA8B,QAAA,CAAA,OAAA,CAA9B,CAAP;AACH,GAHD;;AAKA,EAAA,gBAAe,CAAA,SAAf,CAAe,eAAf,GAAA,UAAgB,UAAhB,EAAsC;AAClC,WAAO,MAAM,CAAC,SAAP,CAAiB,eAAjB,CAAiC,UAAjC,CAAP;AACH,GAFD;;AAIM,EAAA,gBAAA,CAAA,SAAA,CAAA,WAAA,GAAN,UAAkB,SAAlB,EAAoD,WAApD,EAA0E,SAA1E,EAA+F;;;AAC3F,eAAA,CAAA;AAAA;AAAA,UAAO,MAAM,CAAC,SAAP,CAAiB,MAAjB,CAAwB,WAAxB,CAAoC,SAApC,EAA+C,WAA/C,EAA4D,SAA5D,CAAP,CAAA;;;AACH,GAFK;;AAIA,EAAA,gBAAS,CAAA,SAAT,CAAS,SAAT,GAAN,UAAgB,GAAhB,EAA8B;;;AAC1B,eAAA,CAAA;AAAA;AAAA,UAAO,MAAM,CAAC,SAAP,CAAiB,MAAjB,CAAwB,SAAxB,CAAkC,cAAlC,EAAkD,GAAlD,CAAP,CAAA;;;AACH,GAFK;;AAIA,EAAA,gBAAS,CAAA,SAAT,CAAS,SAAT,GAAN,UAAgB,OAAhB,EAAqC,SAArC,EAAuE,WAAvE,EAA6F,SAA7F,EAAkH;;;AAC9G,eAAA,CAAA;AAAA;AAAA,UAAO,MAAM,CAAC,SAAP,CAAiB,MAAjB,CAAwB,SAAxB,CAAkC,cAAlC,EAAkD,OAAlD,EAA2D,SAA3D,EAAsE,WAAtE,EAAmF,SAAnF,CAAP,CAAA;;;AACH,GAFK;;AAIA,EAAA,gBAAA,CAAA,SAAA,CAAA,IAAA,GAAN,UAAW,SAAX,EAA2C,GAA3C,EAA2D,IAA3D,EAA4E;;;AACxE,eAAA,CAAA;AAAA;AAAA,UAAO,MAAM,CAAC,SAAP,CAAiB,MAAjB,CAAwB,IAAxB,CAA6B,SAA7B,EAAwC,GAAxC,EAA6C,IAA7C,CAAP,CAAA;;;AACH,GAFK;;AAIA,EAAA,gBAAA,CAAA,SAAA,CAAA,MAAA,GAAN,UAAa,SAAb,EAA6C,IAA7C,EAA6D;;;AACzD,eAAA,CAAA;AAAA;AAAA,UAAO,MAAM,CAAC,SAAP,CAAiB,MAAjB,CAAwB,MAAxB,CAA+B,SAA/B,EAA0C,IAA1C,CAAP,CAAA;;;AACH,GAFK;;AAGV,SAAC,gBAAD;AAAC,CA7BD,EAAA","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\r\nimport { ISubtleCrypto } from \"./ISubtleCrypto\";\r\n\r\ndeclare global {\r\n    interface Window {\r\n        msrCrypto: Crypto & {\r\n            initPrng: (entropy: Uint8Array | number[]) => void\r\n        }\r\n    }\r\n}\r\n\r\nexport class MsrBrowserCrypto implements ISubtleCrypto {\r\n    initPrng(entropy : Uint8Array): void {\r\n        // Turn into array, as initPrng seems to not always like Uint8Array (even though it should support both)\r\n        return window.msrCrypto.initPrng([...entropy]);\r\n    }\r\n\r\n    getRandomValues(dataBuffer: Uint8Array): Uint8Array {\r\n        return window.msrCrypto.getRandomValues(dataBuffer);\r\n    }\r\n\r\n    async generateKey(algorithm: RsaHashedKeyGenParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKeyPair> {\r\n        return window.msrCrypto.subtle.generateKey(algorithm, extractable, keyUsages) as Promise<CryptoKeyPair>;\r\n    }\r\n\r\n    async exportKey(key: CryptoKey): Promise<JsonWebKey> {\r\n        return window.msrCrypto.subtle.exportKey(KEY_FORMAT_JWK, key) as Promise<JsonWebKey> as Promise<JsonWebKey>;\r\n    }\r\n\r\n    async importKey(keyData: JsonWebKey, algorithm: RsaHashedImportParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey> {\r\n        return window.msrCrypto.subtle.importKey(KEY_FORMAT_JWK, keyData, algorithm, extractable, keyUsages) as Promise<CryptoKey>;\r\n    }\r\n\r\n    async sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\r\n        return window.msrCrypto.subtle.sign(algorithm, key, data) as Promise<ArrayBuffer>;\r\n    }\r\n\r\n    async digest(algorithm: AlgorithmIdentifier, data: Uint8Array): Promise<ArrayBuffer> {\r\n        return window.msrCrypto.subtle.digest(algorithm, data) as Promise<ArrayBuffer>; \r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}