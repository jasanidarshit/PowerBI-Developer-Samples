{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserAuthError, BrowserAuthErrorMessage } from '../error/BrowserAuthError.js';\nimport { DatabaseStorage } from './DatabaseStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\r\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\r\n */\n\nvar AsyncMemoryStorage =\n/** @class */\nfunction () {\n  function AsyncMemoryStorage(logger, storeName) {\n    this.inMemoryCache = new MemoryStorage();\n    this.indexedDBCache = new DatabaseStorage();\n    this.logger = logger;\n    this.storeName = storeName;\n  }\n\n  AsyncMemoryStorage.prototype.handleDatabaseAccessError = function (error) {\n    if (error instanceof BrowserAuthError && error.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code) {\n      this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n    } else {\n      throw error;\n    }\n  };\n  /**\r\n   * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\r\n   * storage object if item isn't found in-memory.\r\n   * @param key\r\n   */\n\n\n  AsyncMemoryStorage.prototype.getItem = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var item, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            item = this.inMemoryCache.getItem(key);\n            if (!!item) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n            return [4\n            /*yield*/\n            , this.indexedDBCache.getItem(key)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 3:\n            e_1 = _a.sent();\n            this.handleDatabaseAccessError(e_1);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            , item];\n        }\n      });\n    });\n  };\n  /**\r\n   * Sets the item in the in-memory cache and then tries to set it in the asynchronous\r\n   * storage object with the given key.\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  AsyncMemoryStorage.prototype.setItem = function (key, value) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.inMemoryCache.setItem(key, value);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.indexedDBCache.setItem(key, value)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_2 = _a.sent();\n            this.handleDatabaseAccessError(e_2);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\r\n   * @param key\r\n   */\n\n\n  AsyncMemoryStorage.prototype.removeItem = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.inMemoryCache.removeItem(key);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.indexedDBCache.removeItem(key)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_3 = _a.sent();\n            this.handleDatabaseAccessError(e_3);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\r\n   * asynchronous storage object.\r\n   */\n\n\n  AsyncMemoryStorage.prototype.getKeys = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var cacheKeys, e_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            cacheKeys = this.inMemoryCache.getKeys();\n            if (!(cacheKeys.length === 0)) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n            return [4\n            /*yield*/\n            , this.indexedDBCache.getKeys()];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 3:\n            e_4 = _a.sent();\n            this.handleDatabaseAccessError(e_4);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            , cacheKeys];\n        }\n      });\n    });\n  };\n  /**\r\n   * Returns true or false if the given key is present in the cache.\r\n   * @param key\r\n   */\n\n\n  AsyncMemoryStorage.prototype.containsKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var containsKey, e_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            containsKey = this.inMemoryCache.containsKey(key);\n            if (!!containsKey) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n            return [4\n            /*yield*/\n            , this.indexedDBCache.containsKey(key)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 3:\n            e_5 = _a.sent();\n            this.handleDatabaseAccessError(e_5);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            , containsKey];\n        }\n      });\n    });\n  };\n  /**\r\n   * Clears in-memory Map\r\n   */\n\n\n  AsyncMemoryStorage.prototype.clearInMemory = function () {\n    // InMemory cache is a Map instance, clear is straightforward\n    this.logger.verbose(\"Deleting in-memory keystore \" + this.storeName);\n    this.inMemoryCache.clear();\n    this.logger.verbose(\"In-memory keystore \" + this.storeName + \" deleted\");\n  };\n  /**\r\n   * Tries to delete the IndexedDB database\r\n   * @returns\r\n   */\n\n\n  AsyncMemoryStorage.prototype.clearPersistent = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var dbDeleted, e_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            this.logger.verbose(\"Deleting persistent keystore\");\n            return [4\n            /*yield*/\n            , this.indexedDBCache.deleteDatabase()];\n\n          case 1:\n            dbDeleted = _a.sent();\n\n            if (dbDeleted) {\n              this.logger.verbose(\"Persistent keystore deleted\");\n            }\n\n            return [2\n            /*return*/\n            , dbDeleted];\n\n          case 2:\n            e_6 = _a.sent();\n            this.handleDatabaseAccessError(e_6);\n            return [2\n            /*return*/\n            , false];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return AsyncMemoryStorage;\n}();\n\nexport { AsyncMemoryStorage };","map":{"version":3,"sources":["../../src/cache/AsyncMemoryStorage.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Logger } from \"@azure/msal-common\";\r\nimport { BrowserAuthError, BrowserAuthErrorMessage } from \"../error/BrowserAuthError\";\r\nimport { DatabaseStorage } from \"./DatabaseStorage\";\r\nimport { IAsyncStorage } from \"./IAsyncMemoryStorage\";\r\nimport { MemoryStorage } from \"./MemoryStorage\";\r\n\r\n/**\r\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\r\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\r\n */\r\nexport class AsyncMemoryStorage<T> implements IAsyncStorage<T> {\r\n    private inMemoryCache: MemoryStorage<T>;\r\n    private indexedDBCache: DatabaseStorage<T>;\r\n    private logger: Logger;\r\n    private storeName: string;\r\n\r\n    constructor(logger: Logger, storeName: string) {\r\n        this.inMemoryCache = new MemoryStorage<T>();\r\n        this.indexedDBCache = new DatabaseStorage<T>();\r\n        this.logger = logger;\r\n        this.storeName = storeName;\r\n    }\r\n\r\n    private handleDatabaseAccessError(error: unknown): void {\r\n        if (error instanceof BrowserAuthError && error.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code) {\r\n            this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\r\n        } else {\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\r\n     * storage object if item isn't found in-memory.\r\n     * @param key \r\n     */\r\n    async getItem(key: string): Promise<T | null> {\r\n        const item = this.inMemoryCache.getItem(key);\r\n        if(!item) {\r\n            try {\r\n                this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\r\n                return await this.indexedDBCache.getItem(key);\r\n            } catch (e) {\r\n                this.handleDatabaseAccessError(e);\r\n            }\r\n        }\r\n        return item;\r\n    }\r\n\r\n    /**\r\n     * Sets the item in the in-memory cache and then tries to set it in the asynchronous\r\n     * storage object with the given key.\r\n     * @param key \r\n     * @param value \r\n     */\r\n    async setItem(key: string, value: T): Promise<void> {\r\n        this.inMemoryCache.setItem(key, value);\r\n        try {\r\n            await this.indexedDBCache.setItem(key, value);\r\n        } catch (e) {\r\n            this.handleDatabaseAccessError(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\r\n     * @param key \r\n     */\r\n    async removeItem(key: string): Promise<void> {\r\n        this.inMemoryCache.removeItem(key);\r\n        try {\r\n            await this.indexedDBCache.removeItem(key);\r\n        } catch (e) {\r\n            this.handleDatabaseAccessError(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the \r\n     * asynchronous storage object.\r\n     */\r\n    async getKeys(): Promise<string[]> {\r\n        const cacheKeys = this.inMemoryCache.getKeys();\r\n        if (cacheKeys.length === 0) {\r\n            try {\r\n                this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\r\n                return await this.indexedDBCache.getKeys();\r\n            } catch (e) {\r\n                this.handleDatabaseAccessError(e);\r\n            }\r\n        }\r\n        return cacheKeys;\r\n    }\r\n\r\n    /**\r\n     * Returns true or false if the given key is present in the cache.\r\n     * @param key \r\n     */\r\n    async containsKey(key: string): Promise<boolean> {\r\n        const containsKey = this.inMemoryCache.containsKey(key);\r\n        if(!containsKey) {\r\n            try {\r\n                this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\r\n                return await this.indexedDBCache.containsKey(key);\r\n            } catch (e) {\r\n                this.handleDatabaseAccessError(e);\r\n            }\r\n        }\r\n        return containsKey;\r\n    }\r\n\r\n    /**\r\n     * Clears in-memory Map\r\n     */\r\n    clearInMemory(): void {\r\n        // InMemory cache is a Map instance, clear is straightforward\r\n        this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\r\n        this.inMemoryCache.clear();\r\n        this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\r\n    }\r\n\r\n    /**\r\n     * Tries to delete the IndexedDB database\r\n     * @returns\r\n     */\r\n    async clearPersistent(): Promise<boolean> {\r\n        try {\r\n            this.logger.verbose(\"Deleting persistent keystore\");\r\n            const dbDeleted = await this.indexedDBCache.deleteDatabase();\r\n            if (dbDeleted) {\r\n                this.logger.verbose(\"Persistent keystore deleted\");\r\n            }\r\n            \r\n            return dbDeleted;\r\n        } catch (e) {\r\n            this.handleDatabaseAccessError(e);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}