{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { __awaiter, __assign, __extends, __generator } from '../_virtual/_tslib.js';\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { name, version } from '../packageMetadata.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\n\nvar CacheManager =\n/** @class */\nfunction () {\n  function CacheManager(clientId, cryptoImpl, logger) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n\n\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n\n    var allAccountKeys = this.getAccountKeys();\n\n    if (allAccountKeys.length < 1) {\n      return [];\n    }\n\n    var accountEntities = allAccountKeys.reduce(function (accounts, key) {\n      var entity = _this.getAccount(key);\n\n      if (!entity) {\n        return accounts;\n      }\n\n      accounts.push(entity);\n      return accounts;\n    }, []);\n\n    if (accountEntities.length < 1) {\n      return [];\n    } else {\n      var allAccounts = accountEntities.map(function (accountEntity) {\n        return _this.getAccountInfoFromEntity(accountEntity);\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * Gets accountInfo object based on provided filters\r\n   */\n\n\n  CacheManager.prototype.getAccountInfoFilteredBy = function (accountFilter) {\n    var allAccounts = this.getAccountsFilteredBy(accountFilter);\n\n    if (allAccounts.length > 0) {\n      return this.getAccountInfoFromEntity(allAccounts[0]);\n    } else {\n      return null;\n    }\n  };\n\n  CacheManager.prototype.getAccountInfoFromEntity = function (accountEntity) {\n    var accountInfo = accountEntity.getAccountInfo();\n    var idToken = this.getIdToken(accountInfo);\n\n    if (idToken) {\n      accountInfo.idToken = idToken.secret;\n      accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\n    }\n\n    return accountInfo;\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n\n\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!cacheRecord) {\n              throw ClientAuthError.createNullOrUndefinedCacheRecord();\n            }\n\n            if (!!cacheRecord.account) {\n              this.setAccount(cacheRecord.account);\n            }\n\n            if (!!cacheRecord.idToken) {\n              this.setIdTokenCredential(cacheRecord.idToken);\n            }\n\n            if (!!!cacheRecord.accessToken) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.saveAccessToken(cacheRecord.accessToken)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            if (!!cacheRecord.refreshToken) {\n              this.setRefreshTokenCredential(cacheRecord.refreshToken);\n            }\n\n            if (!!cacheRecord.appMetadata) {\n              this.setAppMetadata(cacheRecord.appMetadata);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accessTokenFilter, tokenKeys, currentScopes, removedAccessTokens;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            accessTokenFilter = {\n              clientId: credential.clientId,\n              credentialType: credential.credentialType,\n              environment: credential.environment,\n              homeAccountId: credential.homeAccountId,\n              realm: credential.realm,\n              tokenType: credential.tokenType,\n              requestedClaimsHash: credential.requestedClaimsHash\n            };\n            tokenKeys = this.getTokenKeys();\n            currentScopes = ScopeSet.fromString(credential.target);\n            removedAccessTokens = [];\n            tokenKeys.accessToken.forEach(function (key) {\n              if (!_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n                return;\n              }\n\n              var tokenEntity = _this.getAccessTokenCredential(key);\n\n              if (tokenEntity && _this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n                var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                  removedAccessTokens.push(_this.removeAccessToken(key));\n                }\n              }\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedAccessTokens)];\n\n          case 1:\n            _a.sent();\n\n            this.setAccessTokenCredential(credential);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    var _this = this;\n\n    var allAccountKeys = this.getAccountKeys();\n    var matchingAccounts = [];\n    allAccountKeys.forEach(function (cacheKey) {\n      if (!_this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\n        // Don't parse value if the key doesn't match the account filters\n        return;\n      }\n\n      var entity = _this.getAccount(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!accountFilter.homeAccountId && !_this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n\n      if (!!accountFilter.localAccountId && !_this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\n        return;\n      }\n\n      if (!!accountFilter.username && !_this.matchUsername(entity, accountFilter.username)) {\n        return;\n      }\n\n      if (!!accountFilter.environment && !_this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n\n      if (!!accountFilter.realm && !_this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n\n      if (!!accountFilter.nativeAccountId && !_this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n   * @param key\r\n   * @param homeAccountId\r\n   * @param tenantId\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.isAccountKey = function (key, homeAccountId, tenantId) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n      // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n\n    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n      return false;\n    }\n\n    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n      return false;\n    } // Do not check environment as aliasing can cause false negatives\n\n\n    return true;\n  };\n  /**\r\n   * Returns true if the given key matches our credential key schema.\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isCredentialKey = function (key) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n      // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n\n    var lowerCaseKey = key.toLowerCase(); // Credential keys must indicate what credential type they represent\n\n    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n      // Refresh tokens must contain the client id or family id\n      var clientIdValidation = \"\" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + this.clientId + Separators.CACHE_KEY_SEPARATOR;\n      var familyIdValidation = \"\" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + THE_FAMILY_ID + Separators.CACHE_KEY_SEPARATOR;\n\n      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n        return false;\n      }\n    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n      // Tokens must contain the clientId\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Returns whether or not the given credential entity matches the filter\r\n   * @param entity\r\n   * @param filter\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.credentialMatchesFilter = function (entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\r\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n     */\n\n\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\r\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n     */\n\n\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    } // If request OR cached entity has requested Claims Hash, check if they match\n\n\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    } // Access Token with Auth Scheme specific matching\n\n\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      } // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n\n\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAppMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAuthorityMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAllAccounts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var allAccountKeys, removedAccounts;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allAccountKeys = this.getAccountKeys();\n            removedAccounts = [];\n            allAccountKeys.forEach(function (cacheKey) {\n              removedAccounts.push(_this.removeAccount(cacheKey));\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedAccounts)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes the account and related tokens for a given account key\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            account = this.getAccount(accountKey);\n\n            if (!account) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n\n            return [4\n            /*yield*/\n            , this.removeAccountContext(account)];\n\n          case 1:\n            _a.sent();\n\n            this.removeItem(accountKey);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccountContext = function (account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var allTokenKeys, accountId, removedCredentials;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allTokenKeys = this.getTokenKeys();\n            accountId = account.generateAccountId();\n            removedCredentials = [];\n            allTokenKeys.idToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                _this.removeIdToken(key);\n              }\n            });\n            allTokenKeys.accessToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                removedCredentials.push(_this.removeAccessToken(key));\n              }\n            });\n            allTokenKeys.refreshToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                _this.removeRefreshToken(key);\n              }\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedCredentials)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.removeAccessToken = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var credential, accessTokenWithAuthSchemeEntity, kid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            credential = this.getAccessTokenCredential(key);\n\n            if (!credential) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3\n            /*break*/\n            , 4];\n            if (!(credential.tokenType === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 4];\n            accessTokenWithAuthSchemeEntity = credential;\n            kid = accessTokenWithAuthSchemeEntity.keyId;\n            if (!kid) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.cryptoImpl.removeTokenBindingKey(kid)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            _a.sent();\n\n            throw ClientAuthError.createBindingKeyNotRemovedError();\n\n          case 4:\n            return [2\n            /*return*/\n            , this.removeItem(key)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.readCacheRecord = function (account, request, environment) {\n    var tokenKeys = this.getTokenKeys();\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.getIdToken(account, tokenKeys);\n    var cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\n    var cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment);\n\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n\n\n  CacheManager.prototype.getIdToken = function (account, tokenKeys) {\n    var _this = this;\n\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: account.tenantId\n    };\n    var idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n    var numIdTokens = idTokens.length;\n\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - Multiple id tokens found, clearing them\");\n      idTokens.forEach(function (idToken) {\n        _this.removeIdToken(idToken.generateCredentialKey());\n      });\n      return null;\n    }\n\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n    return idTokens[0];\n  };\n  /**\r\n   * Gets all idTokens matching the given filter\r\n   * @param filter\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.getIdTokensByFilter = function (filter, tokenKeys) {\n    var _this = this;\n\n    var idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    var idTokens = [];\n    idTokenKeys.forEach(function (key) {\n      if (!_this.idTokenKeyMatchesFilter(key, __assign({\n        clientId: _this.clientId\n      }, filter))) {\n        return;\n      }\n\n      var idToken = _this.getIdTokenCredential(key);\n\n      if (idToken && _this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.push(idToken);\n      }\n    });\n    return idTokens;\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.idTokenKeyMatchesFilter = function (inputKey, filter) {\n    var key = inputKey.toLowerCase();\n\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Removes idToken from the cache\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.removeIdToken = function (key) {\n    this.removeItem(key);\n  };\n  /**\r\n   * Removes refresh token from the cache\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.removeRefreshToken = function (key) {\n    this.removeItem(key);\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.getAccessToken = function (account, request, tokenKeys) {\n    var _this = this;\n\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n    var scopes = ScopeSet.createSearchScopes(request.scopes);\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    var accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    var accessTokens = [];\n    accessTokenKeys.forEach(function (key) {\n      // Validate key\n      if (_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        var accessToken = _this.getAccessTokenCredential(key); // Validate value\n\n\n        if (accessToken && _this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    var numAccessTokens = accessTokens.length;\n\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n      return null;\n    } else if (numAccessTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - Multiple access tokens found, clearing them\");\n      accessTokens.forEach(function (accessToken) {\n        _this.removeAccessToken(accessToken.generateCredentialKey());\n      });\n      return null;\n    }\n\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n    return accessTokens[0];\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @param keyMustContainAllScopes\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.accessTokenKeyMatchesFilter = function (inputKey, filter, keyMustContainAllScopes) {\n    var key = inputKey.toLowerCase();\n\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.target) {\n      var scopes = filter.target.asArray();\n\n      for (var i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n\n    return true;\n  };\n  /**\r\n   * Gets all access tokens matching the filter\r\n   * @param filter\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.getAccessTokensByFilter = function (filter) {\n    var _this = this;\n\n    var tokenKeys = this.getTokenKeys();\n    var accessTokens = [];\n    tokenKeys.accessToken.forEach(function (key) {\n      if (!_this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n\n      var accessToken = _this.getAccessTokenCredential(key);\n\n      if (accessToken && _this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n\n\n  CacheManager.prototype.getRefreshToken = function (account, familyRT, tokenKeys) {\n    var _this = this;\n\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    var refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    var refreshTokens = [];\n    refreshTokenKeys.forEach(function (key) {\n      // Validate key\n      if (_this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        var refreshToken = _this.getRefreshTokenCredential(key); // Validate value\n\n\n        if (refreshToken && _this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    var numRefreshTokens = refreshTokens.length;\n\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    } // address the else case after remove functions address environment aliases\n\n\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.refreshTokenKeyMatchesFilter = function (inputKey, filter) {\n    var key = inputKey.toLowerCase();\n\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    } // If familyId is used, clientId is not in the key\n\n\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n\n\n  CacheManager.prototype.readAppMetadataFromCache = function (environment) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: this.clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.isAppMetadataFOCI = function (environment) {\n    var appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n\n\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param entity\r\n   * @param localAccountId\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.matchLocalAccountId = function (entity, localAccountId) {\n    return !!(typeof entity.localAccountId === \"string\" && localAccountId === entity.localAccountId);\n  };\n  /**\r\n   * helper to match usernames\r\n   * @param entity\r\n   * @param username\r\n   * @returns\r\n   */\n\n\n  CacheManager.prototype.matchUsername = function (entity, username) {\n    return !!(typeof entity.username === \"string\" && username.toLowerCase() === entity.username.toLowerCase());\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n\n\n  CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n\n\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n\n\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n\n\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * helper to match nativeAccountId\r\n   * @param entity\r\n   * @param nativeAccountId\r\n   * @returns boolean indicating the match result\r\n   */\n\n\n  CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n\n    var entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  };\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n\n\n  CacheManager.prototype.matchTokenType = function (entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  };\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n\n\n  CacheManager.prototype.matchKeyId = function (entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n\n\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n\n\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n\n    return obj;\n  };\n\n  return CacheManager;\n}();\n\nvar DefaultStorageClass =\n/** @class */\nfunction (_super) {\n  __extends(DefaultStorageClass, _super);\n\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccountKeys = function () {\n    var notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getTokenKeys = function () {\n    var notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var notImplErr;\n      return __generator(this, function (_a) {\n        notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n      });\n    });\n  };\n\n  DefaultStorageClass.prototype.updateCredentialCacheKey = function () {\n    var notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  return DefaultStorageClass;\n}(CacheManager);\n\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"sources":["../../src/cache/CacheManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountFilter, CredentialFilter, ValidCredentialType, AppMetadataFilter, AppMetadataCache, TokenKeys } from \"./utils/CacheTypes\";\r\nimport { CacheRecord } from \"./entities/CacheRecord\";\r\nimport { CredentialType, APP_METADATA, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme, Separators } from \"../utils/Constants\";\r\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AccountEntity } from \"./entities/AccountEntity\";\r\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\r\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\r\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\r\nimport { AuthError } from \"../error/AuthError\";\r\nimport { ICacheManager } from \"./interface/ICacheManager\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\r\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\r\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\r\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { name, version } from \"../packageMetadata\";\r\n\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\r\nexport abstract class CacheManager implements ICacheManager {\r\n    protected clientId: string;\r\n    protected cryptoImpl: ICrypto;\r\n    // Instance of logger for functions defined in the msal-common layer\r\n    private commonLogger: Logger;\r\n\r\n    constructor(clientId: string, cryptoImpl: ICrypto, logger: Logger) {\r\n        this.clientId = clientId;\r\n        this.cryptoImpl = cryptoImpl;\r\n        this.commonLogger = logger.clone(name, version);\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     *  @param accountKey\r\n     */\r\n    abstract getAccount(accountKey: string): AccountEntity | null;\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param account\r\n     */\r\n    abstract setAccount(account: AccountEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param idTokenKey\r\n     */\r\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param idToken\r\n     */\r\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param accessTokenKey\r\n     */\r\n    abstract getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param accessToken\r\n     */\r\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param refreshTokenKey\r\n     */\r\n    abstract getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    abstract getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null;\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    abstract setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;\r\n\r\n    /**\r\n     * fetch cloud discovery metadata entity from the platform cache\r\n     * @param key\r\n     */\r\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\r\n\r\n    /**\r\n     *\r\n     */\r\n    abstract getAuthorityMetadataKeys(): Array<string>;\r\n\r\n    /**\r\n     * set cloud discovery metadata entity to the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    abstract setAuthorityMetadata(key: string, value: AuthorityMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    abstract getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    abstract setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;\r\n\r\n    /**\r\n     * Function to remove an item from cache given its key.\r\n     * @param key\r\n     */\r\n    abstract removeItem(key: string): void;\r\n\r\n    /**\r\n     * Function which returns boolean whether cache contains a specific key.\r\n     * @param key\r\n     */\r\n    abstract containsKey(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which retrieves all current keys from the cache.\r\n     */\r\n    abstract getKeys(): string[];\r\n\r\n    /**\r\n     * Function which retrieves all account keys from the cache\r\n     */\r\n    abstract getAccountKeys(): string[];\r\n\r\n    /**\r\n     * Function which retrieves all token keys from the cache\r\n     */\r\n    abstract getTokenKeys(): TokenKeys;\r\n\r\n    /**\r\n     * Function which clears cache.\r\n     */\r\n    abstract clear(): Promise<void>;\r\n\r\n    /**\r\n     * Function which updates an outdated credential cache key\r\n     */\r\n    abstract updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string;\r\n\r\n    /**\r\n     * Returns all accounts in cache\r\n     */\r\n    getAllAccounts(): AccountInfo[] {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        if (allAccountKeys.length < 1) {\r\n            return [];\r\n        }\r\n\r\n        const accountEntities: AccountEntity[] = allAccountKeys.reduce((accounts: AccountEntity[], key: string) => {\r\n            const entity: AccountEntity | null = this.getAccount(key);\r\n\r\n            if (!entity) {\r\n                return accounts;\r\n            }\r\n            accounts.push(entity);\r\n            return accounts;\r\n        }, []);\r\n\r\n        if (accountEntities.length < 1) {\r\n            return [];\r\n        } else {\r\n            const allAccounts = accountEntities.map<AccountInfo>((accountEntity) => {\r\n                return this.getAccountInfoFromEntity(accountEntity);\r\n            });\r\n            return allAccounts;\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Gets accountInfo object based on provided filters\r\n     */\r\n    getAccountInfoFilteredBy(accountFilter: AccountFilter): AccountInfo | null{\r\n        const allAccounts = this.getAccountsFilteredBy(accountFilter);\r\n        if (allAccounts.length > 0) {\r\n            return this.getAccountInfoFromEntity(allAccounts[0]);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private getAccountInfoFromEntity(accountEntity: AccountEntity): AccountInfo {\r\n        const accountInfo = accountEntity.getAccountInfo();\r\n        const idToken = this.getIdToken(accountInfo);\r\n        if (idToken) {\r\n            accountInfo.idToken = idToken.secret;\r\n            accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\r\n        }\r\n        return accountInfo;\r\n    }\r\n\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord\r\n     */\r\n    async saveCacheRecord(cacheRecord: CacheRecord): Promise<void> {\r\n        if (!cacheRecord) {\r\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\r\n        }\r\n\r\n        if (!!cacheRecord.account) {\r\n            this.setAccount(cacheRecord.account);\r\n        }\r\n\r\n        if (!!cacheRecord.idToken) {\r\n            this.setIdTokenCredential(cacheRecord.idToken);\r\n        }\r\n\r\n        if (!!cacheRecord.accessToken) {\r\n            await this.saveAccessToken(cacheRecord.accessToken);\r\n        }\r\n\r\n        if (!!cacheRecord.refreshToken) {\r\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\r\n        }\r\n\r\n        if (!!cacheRecord.appMetadata) {\r\n            this.setAppMetadata(cacheRecord.appMetadata);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    private async saveAccessToken(credential: AccessTokenEntity): Promise<void> {\r\n        const accessTokenFilter: CredentialFilter = {\r\n            clientId: credential.clientId,\r\n            credentialType: credential.credentialType,\r\n            environment: credential.environment,\r\n            homeAccountId: credential.homeAccountId,\r\n            realm: credential.realm,\r\n            tokenType: credential.tokenType,\r\n            requestedClaimsHash: credential.requestedClaimsHash\r\n        };\r\n\r\n        const tokenKeys = this.getTokenKeys();\r\n        const currentScopes = ScopeSet.fromString(credential.target);\r\n\r\n        const removedAccessTokens: Array<Promise<void>> = [];\r\n        tokenKeys.accessToken.forEach((key) => {\r\n            if(!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\r\n                return;\r\n            }\r\n            \r\n            const tokenEntity = this.getAccessTokenCredential(key);\r\n\r\n            if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\r\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                    removedAccessTokens.push(this.removeAccessToken(key));\r\n                }\r\n            }\r\n        });\r\n        await Promise.all(removedAccessTokens);\r\n        this.setAccessTokenCredential(credential);\r\n    }\r\n\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    getAccountsFilteredBy(accountFilter: AccountFilter): AccountEntity[] {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        const matchingAccounts: AccountEntity[] = [];\r\n\r\n        allAccountKeys.forEach((cacheKey) => {\r\n            if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\r\n                // Don't parse value if the key doesn't match the account filters\r\n                return;\r\n            }\r\n\r\n            const entity: AccountEntity | null = this.getAccount(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.localAccountId && !this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.username && !this.matchUsername(entity, accountFilter.username)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            matchingAccounts.push(entity);\r\n        });\r\n\r\n        return matchingAccounts;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n     * @param key \r\n     * @param homeAccountId \r\n     * @param tenantId \r\n     * @returns \r\n     */\r\n    isAccountKey(key: string, homeAccountId?: string, tenantId?: string): boolean {\r\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\r\n            // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\r\n            return false;\r\n        }\r\n\r\n        if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\r\n            return false;\r\n        }\r\n\r\n        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\r\n            return false;\r\n        }\r\n\r\n        // Do not check environment as aliasing can cause false negatives\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given key matches our credential key schema.\r\n     * @param key \r\n     */\r\n    isCredentialKey(key: string): boolean {\r\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\r\n            // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\r\n            return false;\r\n        }\r\n\r\n        const lowerCaseKey = key.toLowerCase();\r\n        // Credential keys must indicate what credential type they represent\r\n        if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\r\n            // Refresh tokens must contain the client id or family id\r\n            const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\r\n            const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\r\n            if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\r\n                return false;\r\n            }\r\n        } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\r\n            // Tokens must contain the clientId\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the given credential entity matches the filter\r\n     * @param entity \r\n     * @param filter \r\n     * @returns \r\n     */\r\n    credentialMatchesFilter(entity: ValidCredentialType, filter: CredentialFilter): boolean {\r\n        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\r\n            return false;\r\n        }\r\n\r\n        /*\r\n         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n         * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n         */\r\n        if ((typeof filter.homeAccountId === \"string\") && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\r\n            return false;\r\n        }\r\n\r\n        /*\r\n         * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n         * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n         */\r\n        if (!!filter.target && !this.matchTarget(entity, filter.target)) {\r\n            return false;\r\n        }\r\n\r\n        // If request OR cached entity has requested Claims Hash, check if they match\r\n        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\r\n            // Don't match if either is undefined or they are different\r\n            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Access Token with Auth Scheme specific matching\r\n        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\r\n            if(!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\r\n                return false;\r\n            }\r\n\r\n            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\r\n            if (filter.tokenType === AuthenticationScheme.SSH) {\r\n                if(filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n     * @param filter\r\n     */\r\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\r\n        return this.getAppMetadataFilteredByInternal(\r\n            filter.environment,\r\n            filter.clientId,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Support function to help match appMetadata\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    private getAppMetadataFilteredByInternal(\r\n        environment?: string,\r\n        clientId?: string\r\n    ): AppMetadataCache {\r\n\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAppMetadata: AppMetadataCache = {};\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-appMetadata type cache entities\r\n            if (!this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAppMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n\r\n            matchingAppMetadata[cacheKey] = entity;\r\n\r\n        });\r\n\r\n        return matchingAppMetadata;\r\n    }\r\n\r\n    /**\r\n     * retrieve authorityMetadata that contains a matching alias\r\n     * @param filter\r\n     */\r\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\r\n        const allCacheKeys = this.getAuthorityMetadataKeys();\r\n        let matchedEntity = null;\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-authorityMetadata type cache entities\r\n            if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAuthorityMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (entity.aliases.indexOf(host) === -1) {\r\n                return;\r\n            }\r\n\r\n            matchedEntity = entity;\r\n\r\n        });\r\n\r\n        return matchedEntity;\r\n    }\r\n\r\n    /**\r\n     * Removes all accounts and related tokens from cache.\r\n     */\r\n    async removeAllAccounts(): Promise<void> {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        const removedAccounts: Array<Promise<void>> = [];\r\n\r\n        allAccountKeys.forEach((cacheKey) => {\r\n            removedAccounts.push(this.removeAccount(cacheKey));\r\n        });\r\n\r\n        await Promise.all(removedAccounts);\r\n    }\r\n\r\n    /**\r\n     * Removes the account and related tokens for a given account key\r\n     * @param account\r\n     */\r\n    async removeAccount(accountKey: string): Promise<void> {\r\n        const account = this.getAccount(accountKey);\r\n        if (!account) {\r\n            throw ClientAuthError.createNoAccountFoundError();\r\n        }\r\n        await this.removeAccountContext(account);\r\n        this.removeItem(accountKey);\r\n    }\r\n\r\n    /**\r\n     * Removes credentials associated with the provided account\r\n     * @param account\r\n     */\r\n    async removeAccountContext(account: AccountEntity): Promise<void> {\r\n        const allTokenKeys = this.getTokenKeys();\r\n        const accountId = account.generateAccountId();\r\n        const removedCredentials: Array<Promise<void>> = [];\r\n\r\n        allTokenKeys.idToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                this.removeIdToken(key);\r\n            }\r\n        });\r\n\r\n        allTokenKeys.accessToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                removedCredentials.push(this.removeAccessToken(key));\r\n            }\r\n        });\r\n\r\n        allTokenKeys.refreshToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                this.removeRefreshToken(key);\r\n            }\r\n        });\r\n\r\n        await Promise.all(removedCredentials);\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    async removeAccessToken(key: string): Promise<void> {\r\n        const credential = this.getAccessTokenCredential(key);\r\n        if (!credential) {\r\n            return;\r\n        }\r\n\r\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\r\n        if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\r\n            if(credential.tokenType === AuthenticationScheme.POP) {\r\n                const accessTokenWithAuthSchemeEntity = credential as AccessTokenEntity;\r\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\r\n\r\n                if (kid) {\r\n                    try {\r\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\r\n                    } catch (error) {\r\n                        throw ClientAuthError.createBindingKeyNotRemovedError();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Removes all app metadata objects from cache.\r\n     */\r\n    removeAppMetadata(): boolean {\r\n        const allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            if (this.isAppMetadata(cacheKey)) {\r\n                this.removeItem(cacheKey);\r\n            }\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the cached credentials into a cacherecord\r\n     * @param account\r\n     * @param clientId\r\n     * @param scopes\r\n     * @param environment\r\n     * @param authScheme\r\n     */\r\n    readCacheRecord(account: AccountInfo, request: BaseAuthRequest, environment: string): CacheRecord {\r\n        const tokenKeys = this.getTokenKeys();\r\n        const cachedAccount = this.readAccountFromCache(account);\r\n        const cachedIdToken = this.getIdToken(account, tokenKeys);\r\n        const cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\r\n        const cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\r\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment);\r\n\r\n        if (cachedAccount && cachedIdToken) {\r\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\r\n        }\r\n\r\n        return {\r\n            account: cachedAccount,\r\n            idToken: cachedIdToken,\r\n            accessToken: cachedAccessToken,\r\n            refreshToken: cachedRefreshToken,\r\n            appMetadata: cachedAppMetadata,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param account\r\n     */\r\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\r\n        const accountKey: string = AccountEntity.generateAccountCacheKey(account);\r\n        return this.getAccount(accountKey);\r\n    }\r\n\r\n    /**\r\n     * Retrieve IdTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param inputRealm\r\n     */\r\n    getIdToken(account: AccountInfo, tokenKeys?: TokenKeys): IdTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getIdToken called\");\r\n        const idTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: this.clientId,\r\n            realm: account.tenantId,\r\n        };\r\n\r\n        const idTokens: IdTokenEntity[] = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\r\n        const numIdTokens = idTokens.length;\r\n\r\n        if (numIdTokens < 1) {\r\n            this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\r\n            return null;\r\n        } else if (numIdTokens > 1) {\r\n            this.commonLogger.info(\r\n                \"CacheManager:getIdToken - Multiple id tokens found, clearing them\"\r\n            );\r\n            idTokens.forEach((idToken) => {\r\n                this.removeIdToken(idToken.generateCredentialKey());\r\n            });\r\n            return null;\r\n        }\r\n\r\n        this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\r\n        return idTokens[0];\r\n    }\r\n\r\n    /**\r\n     * Gets all idTokens matching the given filter\r\n     * @param filter \r\n     * @returns \r\n     */\r\n    getIdTokensByFilter(filter: CredentialFilter, tokenKeys?: TokenKeys): IdTokenEntity[] {\r\n        const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\r\n\r\n        const idTokens: IdTokenEntity[] = [];\r\n        idTokenKeys.forEach((key) => {\r\n            if (!this.idTokenKeyMatchesFilter(key, {clientId: this.clientId, ...filter})) {\r\n                return;\r\n            }\r\n\r\n            const idToken = this.getIdTokenCredential(key);\r\n            if (idToken && this.credentialMatchesFilter(idToken, filter)) {\r\n                idTokens.push(idToken);\r\n            }\r\n        });\r\n\r\n        return idTokens;\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key \r\n     * @param filter\r\n     * @returns \r\n     */\r\n    idTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes idToken from the cache\r\n     * @param key \r\n     */\r\n    removeIdToken(key: string): void {\r\n        this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Removes refresh token from the cache\r\n     * @param key \r\n     */\r\n    removeRefreshToken(key: string): void {\r\n        this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccessTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param scopes\r\n     * @param authScheme\r\n     */\r\n    getAccessToken(account: AccountInfo, request: BaseAuthRequest, tokenKeys?: TokenKeys): AccessTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getAccessToken called\");\r\n        const scopes =  ScopeSet.createSearchScopes(request.scopes);\r\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle \"bearer\" from ADFS\r\n         */\r\n        const credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\r\n\r\n        const accessTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: credentialType,\r\n            clientId: this.clientId,\r\n            realm: account.tenantId,\r\n            target: scopes,\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n        };\r\n\r\n        const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\r\n        const accessTokens: AccessTokenEntity[] = [];\r\n\r\n        accessTokenKeys.forEach((key) => {\r\n            // Validate key\r\n            if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\r\n                const accessToken = this.getAccessTokenCredential(key);\r\n\r\n                // Validate value\r\n                if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\r\n                    accessTokens.push(accessToken);\r\n                }\r\n            }\r\n        });\r\n\r\n        const numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\r\n            return null;\r\n        } else if (numAccessTokens > 1) {\r\n            this.commonLogger.info(\r\n                \"CacheManager:getAccessToken - Multiple access tokens found, clearing them\"\r\n            );\r\n            accessTokens.forEach((accessToken) => {\r\n                this.removeAccessToken(accessToken.generateCredentialKey());\r\n            });\r\n            return null;\r\n        }\r\n\r\n        this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\r\n        return accessTokens[0];\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key \r\n     * @param filter \r\n     * @param keyMustContainAllScopes \r\n     * @returns \r\n     */\r\n    accessTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter, keyMustContainAllScopes: boolean): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.target) {\r\n            const scopes = filter.target.asArray();\r\n            for (let i = 0; i < scopes.length; i++) {\r\n                if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\r\n                    // When performing a cache lookup a missing scope would be a cache miss\r\n                    return false;\r\n                } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\r\n                    // When performing a cache write, any token with a subset of requested scopes should be replaced\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets all access tokens matching the filter\r\n     * @param filter \r\n     * @returns \r\n     */\r\n    getAccessTokensByFilter(filter: CredentialFilter): AccessTokenEntity[] {\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        const accessTokens: AccessTokenEntity[] = [];\r\n        tokenKeys.accessToken.forEach((key) => {\r\n            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\r\n                return;\r\n            }\r\n\r\n            const accessToken = this.getAccessTokenCredential(key);\r\n            if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {\r\n                accessTokens.push(accessToken);\r\n            }\r\n        });\r\n\r\n        return accessTokens;\r\n    }\r\n\r\n    /**\r\n     * Helper to retrieve the appropriate refresh token from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param familyRT\r\n     */\r\n    getRefreshToken(account: AccountInfo, familyRT: boolean, tokenKeys?: TokenKeys): RefreshTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\r\n        const id = familyRT ? THE_FAMILY_ID : undefined;\r\n        const refreshTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.REFRESH_TOKEN,\r\n            clientId: this.clientId,\r\n            familyId: id,\r\n        };\r\n\r\n        const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\r\n        const refreshTokens: RefreshTokenEntity[] = [];\r\n\r\n        refreshTokenKeys.forEach((key) => {\r\n            // Validate key\r\n            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\r\n                const refreshToken = this.getRefreshTokenCredential(key);\r\n                // Validate value\r\n                if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\r\n                    refreshTokens.push(refreshToken);\r\n                }\r\n            }\r\n        });\r\n\r\n        const numRefreshTokens = refreshTokens.length;\r\n        if (numRefreshTokens < 1) {\r\n            this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\r\n            return null;\r\n        }\r\n        // address the else case after remove functions address environment aliases\r\n\r\n        this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\r\n        return refreshTokens[0] as RefreshTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key\r\n     * @param filter\r\n     */\r\n    refreshTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        // If familyId is used, clientId is not in the key\r\n        if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve AppMetadataEntity from cache\r\n     */\r\n    readAppMetadataFromCache(environment: string): AppMetadataEntity | null {\r\n        const appMetadataFilter: AppMetadataFilter = {\r\n            environment,\r\n            clientId: this.clientId,\r\n        };\r\n\r\n        const appMetadata: AppMetadataCache = this.getAppMetadataFilteredBy(appMetadataFilter);\r\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(appMetadata).map((key) => appMetadata[key]);\r\n\r\n        const numAppMetadata = appMetadataEntries.length;\r\n        if (numAppMetadata < 1) {\r\n            return null;\r\n        } else if (numAppMetadata > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\r\n        }\r\n\r\n        return appMetadataEntries[0] as AppMetadataEntity;\r\n    }\r\n\r\n    /**\r\n     * Return the family_id value associated  with FOCI\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    isAppMetadataFOCI(environment: string): boolean {\r\n        const appMetadata = this.readAppMetadataFromCache(environment);\r\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\r\n    }\r\n\r\n    /**\r\n     * helper to match account ids\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    private matchHomeAccountId(entity: AccountEntity | CredentialEntity, homeAccountId: string): boolean {\r\n        return !!((typeof entity.homeAccountId === \"string\") && (homeAccountId === entity.homeAccountId));\r\n    }\r\n\r\n    /**\r\n     * helper to match account ids\r\n     * @param entity \r\n     * @param localAccountId \r\n     * @returns \r\n     */\r\n    private matchLocalAccountId(entity: AccountEntity, localAccountId: string): boolean {\r\n        return !!((typeof entity.localAccountId === \"string\") && (localAccountId === entity.localAccountId));\r\n    }\r\n\r\n    /**\r\n     * helper to match usernames\r\n     * @param entity \r\n     * @param username \r\n     * @returns \r\n     */\r\n    private matchUsername(entity: AccountEntity, username: string): boolean {\r\n        return !!((typeof entity.username === \"string\") && (username.toLowerCase() === entity.username.toLowerCase()));\r\n    }\r\n\r\n    /**\r\n     * helper to match assertion\r\n     * @param value\r\n     * @param oboAssertion\r\n     */\r\n    private matchUserAssertionHash(entity: CredentialEntity, userAssertionHash: string): boolean {\r\n        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\r\n    }\r\n\r\n    /**\r\n     * helper to match environment\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    private matchEnvironment(entity: AccountEntity | CredentialEntity | AppMetadataEntity, environment: string): boolean {\r\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\r\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * helper to match credential type\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    private matchCredentialType(entity: CredentialEntity, credentialType: string): boolean {\r\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * helper to match client ids\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    private matchClientId(entity: CredentialEntity | AppMetadataEntity, clientId: string): boolean {\r\n        return !!(entity.clientId && clientId === entity.clientId);\r\n    }\r\n\r\n    /**\r\n     * helper to match family ids\r\n     * @param entity\r\n     * @param familyId\r\n     */\r\n    private matchFamilyId(entity: CredentialEntity | AppMetadataEntity, familyId: string): boolean {\r\n        return !!(entity.familyId && familyId === entity.familyId);\r\n    }\r\n\r\n    /**\r\n     * helper to match realm\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    private matchRealm(entity: AccountEntity | CredentialEntity, realm: string): boolean {\r\n        return !!(entity.realm && realm === entity.realm);\r\n    }\r\n\r\n    /**\r\n     * helper to match nativeAccountId\r\n     * @param entity\r\n     * @param nativeAccountId\r\n     * @returns boolean indicating the match result\r\n     */\r\n    private matchNativeAccountId(entity: AccountEntity, nativeAccountId: string): boolean {\r\n        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    private matchTarget(entity: CredentialEntity, target: ScopeSet): boolean {\r\n        const isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\r\n\r\n        if ( isNotAccessTokenCredential || !entity.target) {\r\n            return false;\r\n        }\r\n\r\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\r\n\r\n        return entityScopeSet.containsScopeSet(target);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    private matchTokenType(entity: CredentialEntity, tokenType: AuthenticationScheme): boolean {\r\n        return !!(entity.tokenType && entity.tokenType === tokenType);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\r\n        return !!(entity.keyId && entity.keyId === keyId);\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    private isAppMetadata(key: string): boolean {\r\n        return key.indexOf(APP_METADATA) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type authoritymetadata\r\n     * @param key\r\n     */\r\n    protected isAuthorityMetadata(key: string): boolean {\r\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns cache key used for cloud instance metadata\r\n     */\r\n    generateAuthorityMetadataCacheKey(authority: string): string {\r\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\r\n    }\r\n\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    static toObject<T>(obj: T, json: object): T {\r\n        for (const propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    }\r\n}\r\n\r\nexport class DefaultStorageClass extends CacheManager {\r\n    setAccount(): void {\r\n        const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccount(): AccountEntity {\r\n        const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setIdTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getIdTokenCredential(): IdTokenEntity {\r\n        const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAccessTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccessTokenCredential(): AccessTokenEntity {\r\n        const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setRefreshTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getRefreshTokenCredential(): RefreshTokenEntity {\r\n        const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAppMetadata(): void {\r\n        const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAppMetadata(): AppMetadataEntity {\r\n        const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setServerTelemetry(): void {\r\n        const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getServerTelemetry(): ServerTelemetryEntity {\r\n        const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAuthorityMetadata(): void {\r\n        const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\r\n        const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setThrottlingCache(): void {\r\n        const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getThrottlingCache(): ThrottlingEntity {\r\n        const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    removeItem(): boolean {\r\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    containsKey(): boolean {\r\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getKeys(): string[] {\r\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccountKeys(): string[] {\r\n        const notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getTokenKeys(): TokenKeys {\r\n        const notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    async clear(): Promise<void> {\r\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    updateCredentialCacheKey(): string {\r\n        const notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}