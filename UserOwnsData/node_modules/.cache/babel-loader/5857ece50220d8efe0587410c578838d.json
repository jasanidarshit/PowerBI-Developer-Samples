{"ast":null,"code":"/*! @azure/msal-common v13.3.3 2024-06-06 */\n'use strict';\n\nimport { Separators, CacheAccountType, Constants } from '../../utils/Constants.js';\nimport { buildClientInfo } from '../../account/ClientInfo.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\nimport { AuthorityType } from '../../authority/AuthorityType.js';\nimport { ProtocolMode } from '../../authority/ProtocolMode.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      name: Full name for the account, including given name and family name\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      idTokenClaims: Object containing claims parsed from ID token\r\n *      nativeAccountId: Account identifier on the native device\r\n * }\r\n */\n\nvar AccountEntity =\n/** @class */\nfunction () {\n  function AccountEntity() {}\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n\n\n  AccountEntity.prototype.generateAccountId = function () {\n    var accountId = [this.homeAccountId, this.environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n   */\n\n\n  AccountEntity.prototype.generateAccountKey = function () {\n    return AccountEntity.generateAccountCacheKey({\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId\n    });\n  };\n  /**\r\n   * Returns the AccountInfo interface for this account.\r\n   */\n\n\n  AccountEntity.prototype.getAccountInfo = function () {\n    return {\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId,\n      name: this.name,\n      idTokenClaims: this.idTokenClaims,\n      nativeAccountId: this.nativeAccountId,\n      authorityType: this.authorityType\n    };\n  };\n  /**\r\n   * Generates account key from interface\r\n   * @param accountInterface\r\n   */\n\n\n  AccountEntity.generateAccountCacheKey = function (accountInterface) {\n    var accountKey = [accountInterface.homeAccountId, accountInterface.environment || Constants.EMPTY_STRING, accountInterface.tenantId || Constants.EMPTY_STRING];\n    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Build Account cache from account properties.\r\n   * @param accountDetails\r\n   * @param authority\r\n   */\n\n\n  AccountEntity.createAccount = function (accountDetails, authority) {\n    var account = new AccountEntity();\n\n    if (authority.authorityType === AuthorityType.Adfs) {\n      account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\n    } else if (authority.protocolMode === ProtocolMode.AAD) {\n      account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    } else {\n      account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    }\n\n    account.clientInfo = accountDetails.clientInfo;\n    account.homeAccountId = accountDetails.homeAccountId;\n    account.nativeAccountId = accountDetails.nativeAccountId;\n    var env = accountDetails.environment || authority && authority.getPreferredCache();\n\n    if (!env) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n\n    account.environment = env; // non AAD scenarios can have empty realm\n\n    account.realm = accountDetails.idTokenClaims.tid || Constants.EMPTY_STRING;\n    account.idTokenClaims = accountDetails.idTokenClaims; // How do you account for MSA CID here?\n\n    account.localAccountId = accountDetails.idTokenClaims.oid || accountDetails.idTokenClaims.sub || Constants.EMPTY_STRING;\n    /*\r\n     * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\r\n     * In most cases it will contain a single email. This field should not be relied upon if a custom\r\n     * policy is configured to return more than 1 email.\r\n     */\n\n    if (account.authorityType === CacheAccountType.MSSTS_ACCOUNT_TYPE) {\n      var preferredUsername = accountDetails.idTokenClaims.preferred_username;\n      var email = accountDetails.idTokenClaims.emails ? accountDetails.idTokenClaims.emails[0] : null;\n      account.username = preferredUsername || email || \"\";\n    } else {\n      account.username = accountDetails.idTokenClaims.upn || \"\";\n    }\n\n    account.name = accountDetails.idTokenClaims.name;\n    account.cloudGraphHostName = accountDetails.cloudGraphHostName;\n    account.msGraphHost = accountDetails.msGraphHost;\n    return account;\n  };\n  /**\r\n   * Creates an account object from AccountInfo\r\n   * @param accountInfo\r\n   * @param cloudGraphHostName\r\n   * @param msGraphHost\r\n   * @returns AccountEntity\r\n   */\n\n\n  AccountEntity.createFromAccountInfo = function (accountInfo, cloudGraphHostName, msGraphHost) {\n    var account = new AccountEntity();\n    account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = accountInfo.homeAccountId;\n    account.localAccountId = accountInfo.localAccountId;\n    account.nativeAccountId = accountInfo.nativeAccountId;\n    account.realm = accountInfo.tenantId;\n    account.environment = accountInfo.environment;\n    account.username = accountInfo.username;\n    account.name = accountInfo.name;\n    account.idTokenClaims = accountInfo.idTokenClaims;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    return account;\n  };\n  /**\r\n   * Generate HomeAccountId from server response\r\n   * @param serverClientInfo\r\n   * @param authType\r\n   */\n\n\n  AccountEntity.generateHomeAccountId = function (serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {\n    var accountId = (idTokenClaims === null || idTokenClaims === void 0 ? void 0 : idTokenClaims.sub) ? idTokenClaims.sub : Constants.EMPTY_STRING; // since ADFS does not have tid and does not set client_info\n\n    if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {\n      return accountId;\n    } // for cases where there is clientInfo\n\n\n    if (serverClientInfo) {\n      try {\n        var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\n\n        if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {\n          return \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;\n        }\n      } catch (e) {}\n    } // default to \"sub\" claim\n\n\n    logger.verbose(\"No client info in response\");\n    return accountId;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n\n\n  AccountEntity.isAccountEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  };\n  /**\r\n   * Helper function to determine whether 2 accountInfo objects represent the same account\r\n   * @param accountA\r\n   * @param accountB\r\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n   */\n\n\n  AccountEntity.accountInfoIsEqual = function (accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n\n    var claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n\n    if (compareClaims) {\n      var accountAClaims = accountA.idTokenClaims || {};\n      var accountBClaims = accountB.idTokenClaims || {}; // issued at timestamp and nonce are expected to change each time a new id token is acquired\n\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;\n  };\n\n  return AccountEntity;\n}();\n\nexport { AccountEntity };","map":{"version":3,"sources":["../../../src/cache/entities/AccountEntity.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    Separators,\r\n    CacheAccountType,\r\n    Constants,\r\n} from \"../../utils/Constants\";\r\nimport { Authority } from \"../../authority/Authority\";\r\nimport { ICrypto } from \"../../crypto/ICrypto\";\r\nimport { buildClientInfo } from \"../../account/ClientInfo\";\r\nimport { StringUtils } from \"../../utils/StringUtils\";\r\nimport { AccountInfo } from \"../../account/AccountInfo\";\r\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\r\nimport { AuthorityType } from \"../../authority/AuthorityType\";\r\nimport { Logger } from \"../../logger/Logger\";\r\nimport { TokenClaims } from \"../../account/TokenClaims\";\r\nimport { ProtocolMode } from \"../../authority/ProtocolMode\";\r\n\r\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      name: Full name for the account, including given name and family name\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      idTokenClaims: Object containing claims parsed from ID token\r\n *      nativeAccountId: Account identifier on the native device\r\n * }\r\n */\r\nexport class AccountEntity {\r\n    homeAccountId: string;\r\n    environment: string;\r\n    realm: string;\r\n    localAccountId: string;\r\n    username: string;\r\n    authorityType: string;\r\n    clientInfo?: string;\r\n    name?: string;\r\n    lastModificationTime?: string;\r\n    lastModificationApp?: string;\r\n    cloudGraphHostName?: string;\r\n    msGraphHost?: string;\r\n    idTokenClaims?: TokenClaims;\r\n    nativeAccountId?: string;\r\n\r\n    /**\r\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n     */\r\n    generateAccountId(): string {\r\n        const accountId: Array<string> = [this.homeAccountId, this.environment];\r\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n     */\r\n    generateAccountKey(): string {\r\n        return AccountEntity.generateAccountCacheKey({\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the AccountInfo interface for this account.\r\n     */\r\n    getAccountInfo(): AccountInfo {\r\n        return {\r\n            homeAccountId: this.homeAccountId,\r\n            environment: this.environment,\r\n            tenantId: this.realm,\r\n            username: this.username,\r\n            localAccountId: this.localAccountId,\r\n            name: this.name,\r\n            idTokenClaims: this.idTokenClaims,\r\n            nativeAccountId: this.nativeAccountId,\r\n            authorityType: this.authorityType\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates account key from interface\r\n     * @param accountInterface\r\n     */\r\n    static generateAccountCacheKey(accountInterface: AccountInfo): string {\r\n        const accountKey = [\r\n            accountInterface.homeAccountId,\r\n            accountInterface.environment || Constants.EMPTY_STRING,\r\n            accountInterface.tenantId || Constants.EMPTY_STRING,\r\n        ];\r\n\r\n        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Build Account cache from account properties.\r\n     * @param accountDetails\r\n     * @param authority\r\n     */\r\n    static createAccount(\r\n        accountDetails: {\r\n            homeAccountId: string,\r\n            idTokenClaims: TokenClaims,\r\n            clientInfo?: string,\r\n            cloudGraphHostName?: string,\r\n            msGraphHost?: string,\r\n            environment?: string,\r\n            nativeAccountId?: string\r\n        },\r\n        authority: Authority\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        if (authority.authorityType === AuthorityType.Adfs) {\r\n            account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\r\n        } else if (authority.protocolMode === ProtocolMode.AAD) {\r\n            account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\r\n        } else {\r\n            account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\r\n        }\r\n\r\n        account.clientInfo = accountDetails.clientInfo;\r\n        account.homeAccountId = accountDetails.homeAccountId;\r\n        account.nativeAccountId = accountDetails.nativeAccountId;\r\n\r\n        const env = accountDetails.environment || (authority && authority.getPreferredCache());\r\n\r\n        if (!env) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        account.environment = env;\r\n        // non AAD scenarios can have empty realm\r\n        account.realm = accountDetails.idTokenClaims.tid || Constants.EMPTY_STRING;\r\n\r\n        account.idTokenClaims = accountDetails.idTokenClaims;\r\n\r\n        // How do you account for MSA CID here?\r\n        account.localAccountId = accountDetails.idTokenClaims.oid ||  accountDetails.idTokenClaims.sub || Constants.EMPTY_STRING;\r\n\r\n        /*\r\n         * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\r\n         * In most cases it will contain a single email. This field should not be relied upon if a custom \r\n         * policy is configured to return more than 1 email.\r\n         */\r\n        if (account.authorityType === CacheAccountType.MSSTS_ACCOUNT_TYPE) {\r\n            const preferredUsername = accountDetails.idTokenClaims.preferred_username;\r\n            const email = (accountDetails.idTokenClaims.emails) ? accountDetails.idTokenClaims.emails[0] : null;\r\n                \r\n            account.username = preferredUsername || email || \"\";\r\n        } else {\r\n            account.username = accountDetails.idTokenClaims.upn || \"\";\r\n        }\r\n        account.name = accountDetails.idTokenClaims.name;\r\n\r\n        account.cloudGraphHostName = accountDetails.cloudGraphHostName;\r\n        account.msGraphHost = accountDetails.msGraphHost;\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Creates an account object from AccountInfo\r\n     * @param accountInfo\r\n     * @param cloudGraphHostName\r\n     * @param msGraphHost\r\n     * @returns AccountEntity\r\n     */\r\n    static createFromAccountInfo(\r\n        accountInfo: AccountInfo,\r\n        cloudGraphHostName?: string,\r\n        msGraphHost?: string\r\n    ): AccountEntity {\r\n        const account: AccountEntity = new AccountEntity();\r\n\r\n        account.authorityType =\r\n            accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\r\n        account.homeAccountId = accountInfo.homeAccountId;\r\n        account.localAccountId = accountInfo.localAccountId;\r\n        account.nativeAccountId = accountInfo.nativeAccountId;\r\n        \r\n        account.realm = accountInfo.tenantId;\r\n        account.environment = accountInfo.environment;\r\n\r\n        account.username = accountInfo.username;\r\n        account.name = accountInfo.name;\r\n        account.idTokenClaims = accountInfo.idTokenClaims;\r\n\r\n        account.cloudGraphHostName = cloudGraphHostName;\r\n        account.msGraphHost = msGraphHost;\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     * Generate HomeAccountId from server response\r\n     * @param serverClientInfo\r\n     * @param authType\r\n     */\r\n    static generateHomeAccountId(\r\n        serverClientInfo: string,\r\n        authType: AuthorityType,\r\n        logger: Logger,\r\n        cryptoObj: ICrypto,\r\n        idTokenClaims?: TokenClaims\r\n    ): string {\r\n\r\n        const accountId = idTokenClaims?.sub ? idTokenClaims.sub : Constants.EMPTY_STRING;\r\n\r\n        // since ADFS does not have tid and does not set client_info\r\n        if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {\r\n            return accountId;\r\n        }\r\n\r\n        // for cases where there is clientInfo\r\n        if (serverClientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\r\n                if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {\r\n                    return `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`;\r\n                }\r\n            } catch (e) {}\r\n        }\r\n\r\n        // default to \"sub\" claim\r\n        logger.verbose(\"No client info in response\");\r\n        return accountId;\r\n    }\r\n\r\n    /**\r\n     * Validates an entity: checks for all expected params\r\n     * @param entity\r\n     */\r\n    static isAccountEntity(entity: object): boolean {\r\n\r\n        if (!entity) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            entity.hasOwnProperty(\"homeAccountId\") &&\r\n            entity.hasOwnProperty(\"environment\") &&\r\n            entity.hasOwnProperty(\"realm\") &&\r\n            entity.hasOwnProperty(\"localAccountId\") &&\r\n            entity.hasOwnProperty(\"username\") &&\r\n            entity.hasOwnProperty(\"authorityType\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Helper function to determine whether 2 accountInfo objects represent the same account\r\n     * @param accountA\r\n     * @param accountB\r\n     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n     */\r\n    static accountInfoIsEqual(accountA: AccountInfo | null, accountB: AccountInfo | null, compareClaims?: boolean): boolean {\r\n        if (!accountA || !accountB) {\r\n            return false;\r\n        }\r\n\r\n        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\r\n        if (compareClaims) {\r\n            const accountAClaims = (accountA.idTokenClaims || {}) as TokenClaims;\r\n            const accountBClaims = (accountB.idTokenClaims || {}) as TokenClaims;\r\n\r\n            // issued at timestamp and nonce are expected to change each time a new id token is acquired\r\n            claimsMatch = (accountAClaims.iat === accountBClaims.iat) &&\r\n            (accountAClaims.nonce === accountBClaims.nonce);\r\n        }\r\n\r\n        return (accountA.homeAccountId === accountB.homeAccountId) &&\r\n            (accountA.localAccountId === accountB.localAccountId) &&\r\n            (accountA.username === accountB.username) &&\r\n            (accountA.tenantId === accountB.tenantId) &&\r\n            (accountA.environment === accountB.environment) &&\r\n            (accountA.nativeAccountId === accountB.nativeAccountId) &&\r\n            claimsMatch;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}