{"ast":null,"code":"/*! @azure/msal-browser v2.39.0 2024-06-06 */\n'use strict';\n\nimport { __extends, __assign } from '../_virtual/_tslib.js';\nimport { PerformanceClient } from '@azure/msal-common';\nimport { BrowserCrypto } from '../crypto/BrowserCrypto.js';\nimport { GuidGenerator } from '../crypto/GuidGenerator.js';\nimport { BrowserPerformanceMeasurement } from './BrowserPerformanceMeasurement.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar BrowserPerformanceClient =\n/** @class */\nfunction (_super) {\n  __extends(BrowserPerformanceClient, _super);\n\n  function BrowserPerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry, cryptoOptions) {\n    var _this = _super.call(this, clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) || this;\n\n    _this.browserCrypto = new BrowserCrypto(_this.logger, cryptoOptions);\n    _this.guidGenerator = new GuidGenerator(_this.browserCrypto);\n    return _this;\n  }\n\n  BrowserPerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {\n    return new BrowserPerformanceMeasurement(measureName, correlationId);\n  };\n\n  BrowserPerformanceClient.prototype.generateId = function () {\n    return this.guidGenerator.generateGuid();\n  };\n\n  BrowserPerformanceClient.prototype.getPageVisibility = function () {\n    var _a;\n\n    return ((_a = document.visibilityState) === null || _a === void 0 ? void 0 : _a.toString()) || null;\n  };\n\n  BrowserPerformanceClient.prototype.deleteIncompleteSubMeasurements = function (inProgressEvent) {\n    var rootEvent = this.eventsByCorrelationId.get(inProgressEvent.event.correlationId);\n    var isRootEvent = rootEvent && rootEvent.eventId === inProgressEvent.event.eventId;\n    var incompleteMeasurements = [];\n\n    if (isRootEvent && (rootEvent === null || rootEvent === void 0 ? void 0 : rootEvent.incompleteSubMeasurements)) {\n      rootEvent.incompleteSubMeasurements.forEach(function (subMeasurement) {\n        incompleteMeasurements.push(__assign({}, subMeasurement));\n      });\n    } // Clean up remaining marks for incomplete sub-measurements\n\n\n    if (incompleteMeasurements.length > 0) {\n      BrowserPerformanceMeasurement.flushMeasurements(inProgressEvent.event.correlationId, incompleteMeasurements);\n    }\n  };\n\n  BrowserPerformanceClient.prototype.supportsBrowserPerformanceNow = function () {\n    return typeof window !== \"undefined\" && typeof window.performance !== \"undefined\" && typeof window.performance.now === \"function\";\n  };\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   * Also captures browser page visibilityState.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}\r\n   */\n\n\n  BrowserPerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this; // Capture page visibilityState and then invoke start/end measurement\n\n\n    var startPageVisibility = this.getPageVisibility();\n\n    var inProgressEvent = _super.prototype.startMeasurement.call(this, measureName, correlationId);\n\n    return __assign(__assign({}, inProgressEvent), {\n      endMeasurement: function (event) {\n        var res = inProgressEvent.endMeasurement(__assign({\n          startPageVisibility: startPageVisibility,\n          endPageVisibility: _this.getPageVisibility()\n        }, event));\n\n        _this.deleteIncompleteSubMeasurements(inProgressEvent);\n\n        return res;\n      },\n      discardMeasurement: function () {\n        inProgressEvent.discardMeasurement();\n\n        _this.deleteIncompleteSubMeasurements(inProgressEvent);\n\n        inProgressEvent.measurement.flushMeasurement();\n      }\n    });\n  };\n  /**\r\n   * Adds pre-queue time to preQueueTimeByCorrelationId map.\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {?string} correlationId\r\n   * @returns\r\n   */\n\n\n  BrowserPerformanceClient.prototype.setPreQueueTime = function (eventName, correlationId) {\n    if (!this.supportsBrowserPerformanceNow()) {\n      this.logger.trace(\"BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for \" + eventName);\n      return;\n    }\n\n    if (!correlationId) {\n      this.logger.trace(\"BrowserPerformanceClient: correlationId for \" + eventName + \" not provided, unable to set telemetry queue time\");\n      return;\n    }\n\n    var preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n    /**\r\n     * Manually complete queue measurement if there is an incomplete pre-queue event.\r\n     * Incomplete pre-queue events are instrumentation bugs that should be fixed.\r\n     */\n\n    if (preQueueEvent) {\n      this.logger.trace(\"BrowserPerformanceClient: Incomplete pre-queue \" + preQueueEvent.name + \" found\", correlationId);\n      this.addQueueMeasurement(preQueueEvent.name, correlationId, undefined, true);\n    }\n\n    this.preQueueTimeByCorrelationId.set(correlationId, {\n      name: eventName,\n      time: window.performance.now()\n    });\n  };\n  /**\r\n   * Calculates and adds queue time measurement for given performance event.\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {?string} correlationId\r\n   * @param {?number} queueTime\r\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n   * @returns\r\n   */\n\n\n  BrowserPerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!this.supportsBrowserPerformanceNow()) {\n      this.logger.trace(\"BrowserPerformanceClient: window performance API not available, unable to add queue measurement for \" + eventName);\n      return;\n    }\n\n    if (!correlationId) {\n      this.logger.trace(\"BrowserPerformanceClient: correlationId for \" + eventName + \" not provided, unable to add queue measurement\");\n      return;\n    }\n\n    var preQueueTime = _super.prototype.getPreQueueTime.call(this, eventName, correlationId);\n\n    if (!preQueueTime) {\n      return;\n    }\n\n    var currentTime = window.performance.now();\n\n    var resQueueTime = queueTime || _super.prototype.calculateQueuedTime.call(this, preQueueTime, currentTime);\n\n    return _super.prototype.addQueueMeasurement.call(this, eventName, correlationId, resQueueTime, manuallyCompleted);\n  };\n\n  return BrowserPerformanceClient;\n}(PerformanceClient);\n\nexport { BrowserPerformanceClient };","map":{"version":3,"sources":["../../src/telemetry/BrowserPerformanceClient.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    Logger,\r\n    PerformanceEvent,\r\n    PerformanceEvents,\r\n    IPerformanceClient,\r\n    PerformanceClient,\r\n    IPerformanceMeasurement,\r\n    InProgressPerformanceEvent,\r\n    ApplicationTelemetry,\r\n    SubMeasurement,\r\n    PreQueueEvent\r\n} from \"@azure/msal-common\";\r\nimport { CryptoOptions } from \"../config/Configuration\";\r\nimport { BrowserCrypto } from \"../crypto/BrowserCrypto\";\r\nimport { GuidGenerator } from \"../crypto/GuidGenerator\";\r\nimport { BrowserPerformanceMeasurement } from \"./BrowserPerformanceMeasurement\";\r\n\r\nexport class BrowserPerformanceClient extends PerformanceClient implements IPerformanceClient {\r\n    private browserCrypto: BrowserCrypto;\r\n    private guidGenerator: GuidGenerator;\r\n\r\n    constructor(clientId: string, authority: string, logger: Logger, libraryName: string, libraryVersion: string, applicationTelemetry: ApplicationTelemetry, cryptoOptions: CryptoOptions) {\r\n        super(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry);\r\n        this.browserCrypto = new BrowserCrypto(this.logger, cryptoOptions);\r\n        this.guidGenerator = new GuidGenerator(this.browserCrypto);\r\n    }\r\n\r\n    startPerformanceMeasuremeant(measureName: string, correlationId: string): IPerformanceMeasurement {\r\n        return new BrowserPerformanceMeasurement(measureName, correlationId);\r\n    }\r\n\r\n    generateId() : string {\r\n        return this.guidGenerator.generateGuid();\r\n    }\r\n\r\n    private getPageVisibility(): string | null {\r\n        return document.visibilityState?.toString() || null;\r\n    }\r\n\r\n    private deleteIncompleteSubMeasurements(inProgressEvent: InProgressPerformanceEvent): void {\r\n        const rootEvent = this.eventsByCorrelationId.get(inProgressEvent.event.correlationId);\r\n        const isRootEvent = rootEvent && rootEvent.eventId === inProgressEvent.event.eventId;\r\n        const incompleteMeasurements: SubMeasurement[] = [];\r\n        if (isRootEvent && rootEvent?.incompleteSubMeasurements) {\r\n            rootEvent.incompleteSubMeasurements.forEach((subMeasurement) => {\r\n                incompleteMeasurements.push({...subMeasurement});\r\n            });\r\n        }\r\n        // Clean up remaining marks for incomplete sub-measurements\r\n        if (incompleteMeasurements.length > 0) {\r\n            BrowserPerformanceMeasurement.flushMeasurements(inProgressEvent.event.correlationId, incompleteMeasurements);\r\n        }\r\n    }\r\n\r\n    supportsBrowserPerformanceNow(): boolean {\r\n        return typeof window !== \"undefined\" &&\r\n            typeof window.performance !== \"undefined\" &&\r\n            typeof window.performance.now === \"function\";\r\n    }\r\n\r\n    /**\r\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n     * Also captures browser page visibilityState.\r\n     *\r\n     * @param {PerformanceEvents} measureName\r\n     * @param {?string} [correlationId]\r\n     * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}\r\n     */\r\n    startMeasurement(measureName: PerformanceEvents, correlationId?: string): InProgressPerformanceEvent {\r\n        // Capture page visibilityState and then invoke start/end measurement\r\n        const startPageVisibility = this.getPageVisibility();\r\n\r\n        const inProgressEvent = super.startMeasurement(measureName, correlationId);\r\n\r\n        return {\r\n            ...inProgressEvent,\r\n            endMeasurement: (event?: Partial<PerformanceEvent>): PerformanceEvent | null => {\r\n                const res = inProgressEvent.endMeasurement({\r\n                    startPageVisibility,\r\n                    endPageVisibility: this.getPageVisibility(),\r\n                    ...event\r\n                });\r\n                this.deleteIncompleteSubMeasurements(inProgressEvent);\r\n\r\n                return res;\r\n            },\r\n            discardMeasurement: () => {\r\n                inProgressEvent.discardMeasurement();\r\n                this.deleteIncompleteSubMeasurements(inProgressEvent);\r\n                inProgressEvent.measurement.flushMeasurement();\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Adds pre-queue time to preQueueTimeByCorrelationId map.\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {?string} correlationId\r\n     * @returns\r\n     */\r\n    setPreQueueTime(eventName: PerformanceEvents, correlationId?: string): void {\r\n        if (!this.supportsBrowserPerformanceNow()) {\r\n            this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for ${eventName}`);\r\n            return;\r\n        }\r\n\r\n        if (!correlationId) {\r\n            this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to set telemetry queue time`);\r\n            return;\r\n        }\r\n\r\n        const preQueueEvent: PreQueueEvent | undefined = this.preQueueTimeByCorrelationId.get(correlationId);\r\n        /**\r\n         * Manually complete queue measurement if there is an incomplete pre-queue event.\r\n         * Incomplete pre-queue events are instrumentation bugs that should be fixed.\r\n         */\r\n        if (preQueueEvent) {\r\n            this.logger.trace(`BrowserPerformanceClient: Incomplete pre-queue ${preQueueEvent.name} found`, correlationId);\r\n            this.addQueueMeasurement(preQueueEvent.name, correlationId, undefined, true);\r\n        }\r\n        this.preQueueTimeByCorrelationId.set(correlationId, { name: eventName, time: window.performance.now() });\r\n    }\r\n\r\n    /**\r\n     * Calculates and adds queue time measurement for given performance event.\r\n     *\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {?string} correlationId\r\n     * @param {?number} queueTime\r\n     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n     * @returns\r\n     */\r\n    addQueueMeasurement(eventName: PerformanceEvents, correlationId?: string, queueTime?: number, manuallyCompleted?: boolean): void {\r\n        if (!this.supportsBrowserPerformanceNow()) {\r\n            this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to add queue measurement for ${eventName}`);\r\n            return;\r\n        }\r\n\r\n        if (!correlationId) {\r\n            this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to add queue measurement`);\r\n            return;\r\n        }\r\n\r\n        const preQueueTime = super.getPreQueueTime(eventName, correlationId);\r\n        if (!preQueueTime) {\r\n            return;\r\n        }\r\n\r\n        const currentTime = window.performance.now();\r\n        const resQueueTime = queueTime || super.calculateQueuedTime(preQueueTime, currentTime);\r\n\r\n        return super.addQueueMeasurement(eventName, correlationId, resQueueTime, manuallyCompleted);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}